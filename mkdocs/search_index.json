{
    "docs": [
        {
            "location": "/", 
            "text": "Carry\n\n\nClojureScript single-page application framework inspired by\n\nre-frame\n,\n\nElm Architecture\n,\n\nRedux\n and\n\nCerebral\n.\n\n\nCarry provides a structure for making GUI application code easier to modify, debug, test and be worked on by multiple programmers.\n\n\nThe core of the framework is a simple state management library. \nUI bindings, routing, debugger, etc. are implemented as separate optional \npackages\n.\n\n\n\n\n\n\n\n\nFeatures\n\n\n\n\nFunctional API without globals and macros.\n\n\nAgnostic to UI layer: can be effectively used with \nReagent\n\n(via \ncarry-reagent\n package) or\nany other view layer that is able to re-render UI in response to app model changes.\n\n\nTime traveling debugger\n\ninspired by \nRedux DevTools\n and \nCerebral Debugger\n.\n\n\nLive code editing using \nFigwheel\n and debugger's replay mode.\n\n\nCan work with \nDevcards\n.\n\n\nCore library can be also used in Clojure projects.\n\n\n\n\nPattern\n\n\nCarry enforces:\n\n\n\n\nSeparation of presentation code.\n\n\nEvents as first-class citizens.\n\n\nSplitting event handling code into side-effectful and \"pure\" model updating phases.\n\n\nStoring model in a single observable atom.\n\n\n\n\nIt also advises to decouple view and view model code in the presentation layer:\n\n\n\n\n\n\nAn app is defined by its initial model value, signal handler and action handler.\n\n\nAll app state is stored inside a single model atom.\n\n\nAnyone can read model value at any given time and subscribe to its changes.\n\n\nSignal handler performs side effects and dispatches actions.\n\n\nAnyone can dispatch a new signal: signal handler, views, timers, etc.\n\n\nTypically UI layer dispatches signals on UI events and subscribes to model changes to redraw the GUI when needed.\n\n\nModel can be modified only by dispatching actions.\n\n\nOnly signal handler can dispatch actions.\n\n\nAction handler is a pure function which returns a new model value based on an incoming action.  \n\n\n\n\nExample (counter app)\n\n\nDemo\n,\n\nSource code\n\n\nHTML:\n\n\n!doctype html\n\n\nhtml lang=\nen\n\n\nhead\n\n    \nmeta charset=\nutf-8\n\n    \nmeta name=\nviewport\n content=\nwidth=device-width, initial-scale=1\n\n    \ntitle\nCarry \u2022 Counter\n/title\n\n    \nlink rel=\nicon\n href=\ndata:;base64,iVBORw0KGgo=\n\n\n/head\n\n\nbody\n\n    \ndiv id=\nroot\n/div\n\n    \nscript src=\njs/compiled/frontend.js\n type=\ntext/javascript\n/script\n\n\n/body\n\n\n/html\n\n\n\n\n\nMain file:\n\n\n(ns app.core\n  (:require [counter.core :as counter]\n            [carry.core :as carry]\n            [carry-reagent.core :as carry-reagent]\n            [reagent.core :as r]))\n\n(let [app (carry/app counter/blueprint)\n      [_ app-view] (carry-reagent/connect app counter/view-model counter/view)]\n    (r/render app-view (.getElementById js/document \nroot\n))\n    ((:dispatch-signal app) :on-start))\n\n\n\n\nUI (using \nReagent\n and \ncarry-reagent\n):\n\n\n(ns counter.core\n  (:require [cljs.core.match :refer-macros [match]]\n            [reagent.ratom :refer [reaction]]))\n\n(defn view-model\n  [model]\n  {:counter (reaction (str \n#\n (:val @model)))})\n\n(defn view\n  [{:keys [counter] :as _view-model} dispatch]\n  [:p\n   @counter \n \n\n   [:button {:on-click #(dispatch :on-increment)} \n+\n] \n \n\n   [:button {:on-click #(dispatch :on-decrement)} \n-\n] \n \n\n   [:button {:on-click #(dispatch :on-increment-if-odd)} \nIncrement if odd\n] \n \n\n   [:button {:on-click #(dispatch :on-increment-async)} \nIncrement async\n]])\n\n\n\n\nBlueprint:\n\n\n(def -initial-model {:val 0})\n\n(defn -on-signal\n  [model signal _dispatch-signal dispatch-action]\n  (match signal\n         :on-start nil\n         :on-stop nil\n\n         :on-increment\n         (dispatch-action :increment)\n\n         :on-decrement\n         (dispatch-action :decrement)\n\n         :on-increment-if-odd\n         (when (odd? (:val @model))\n           (dispatch-action :increment))\n\n         :on-increment-async\n         (.setTimeout js/window #(dispatch-action :increment) 1000)))\n\n(defn -on-action\n  [model action]\n  (match action\n         :increment (update model :val inc)\n         :decrement (update model :val dec)))\n\n(def blueprint {:initial-model -initial-model\n                :on-signal     -on-signal\n                :on-action     -on-action})\n\n\n\n\nPackages\n\n\nUI Bindings\n\n\n\n\ncarry-reagent\n\n(bindings for \nReagent\n)\n\n\n\n\nMiddleware\n\n\n\n\ncarry-atom-sync\n\n(creating a bidirectional sync between an app model and a specified atom-like reference)\n\n\ncarry-debugger\n\n(time traveling debugger)\n\n\ncarry-history\n\n(working with browser history)\n\n\ncarry-logging\n\n(console logging)\n\n\ncarry-persistence\n\n(automatic model saving/loading using browser storage)\n\n\ncarry-schema\n\n(model validation using \nSchema\n)\n\n\n\n\nDocumentation\n\n\nMore information can be found at \nthe project site\n:\n\n\n\n\nUser Guide\n\n\nExamples\n\n\nAPI Reference\n\n\nFAQ\n\n\nDeveloper Guide\n\n\n\n\nLicense\n\n\nCopyright \u00a9 2016 Yuri Govorushchenko.\n\n\nReleased under an MIT license.", 
            "title": "Readme"
        }, 
        {
            "location": "/#carry", 
            "text": "ClojureScript single-page application framework inspired by re-frame , Elm Architecture , Redux  and Cerebral .  Carry provides a structure for making GUI application code easier to modify, debug, test and be worked on by multiple programmers.  The core of the framework is a simple state management library. \nUI bindings, routing, debugger, etc. are implemented as separate optional  packages .", 
            "title": "Carry"
        }, 
        {
            "location": "/#features", 
            "text": "Functional API without globals and macros.  Agnostic to UI layer: can be effectively used with  Reagent \n(via  carry-reagent  package) or\nany other view layer that is able to re-render UI in response to app model changes.  Time traveling debugger \ninspired by  Redux DevTools  and  Cerebral Debugger .  Live code editing using  Figwheel  and debugger's replay mode.  Can work with  Devcards .  Core library can be also used in Clojure projects.", 
            "title": "Features"
        }, 
        {
            "location": "/#pattern", 
            "text": "Carry enforces:   Separation of presentation code.  Events as first-class citizens.  Splitting event handling code into side-effectful and \"pure\" model updating phases.  Storing model in a single observable atom.   It also advises to decouple view and view model code in the presentation layer:    An app is defined by its initial model value, signal handler and action handler.  All app state is stored inside a single model atom.  Anyone can read model value at any given time and subscribe to its changes.  Signal handler performs side effects and dispatches actions.  Anyone can dispatch a new signal: signal handler, views, timers, etc.  Typically UI layer dispatches signals on UI events and subscribes to model changes to redraw the GUI when needed.  Model can be modified only by dispatching actions.  Only signal handler can dispatch actions.  Action handler is a pure function which returns a new model value based on an incoming action.", 
            "title": "Pattern"
        }, 
        {
            "location": "/#example-counter-app", 
            "text": "Demo , Source code  HTML:  !doctype html  html lang= en  head \n     meta charset= utf-8 \n     meta name= viewport  content= width=device-width, initial-scale=1 \n     title Carry \u2022 Counter /title \n     link rel= icon  href= data:;base64,iVBORw0KGgo=  /head  body \n     div id= root /div \n     script src= js/compiled/frontend.js  type= text/javascript /script  /body  /html   Main file:  (ns app.core\n  (:require [counter.core :as counter]\n            [carry.core :as carry]\n            [carry-reagent.core :as carry-reagent]\n            [reagent.core :as r]))\n\n(let [app (carry/app counter/blueprint)\n      [_ app-view] (carry-reagent/connect app counter/view-model counter/view)]\n    (r/render app-view (.getElementById js/document  root ))\n    ((:dispatch-signal app) :on-start))  UI (using  Reagent  and  carry-reagent ):  (ns counter.core\n  (:require [cljs.core.match :refer-macros [match]]\n            [reagent.ratom :refer [reaction]]))\n\n(defn view-model\n  [model]\n  {:counter (reaction (str  #  (:val @model)))})\n\n(defn view\n  [{:keys [counter] :as _view-model} dispatch]\n  [:p\n   @counter    \n   [:button {:on-click #(dispatch :on-increment)}  + ]    \n   [:button {:on-click #(dispatch :on-decrement)}  - ]    \n   [:button {:on-click #(dispatch :on-increment-if-odd)}  Increment if odd ]    \n   [:button {:on-click #(dispatch :on-increment-async)}  Increment async ]])  Blueprint:  (def -initial-model {:val 0})\n\n(defn -on-signal\n  [model signal _dispatch-signal dispatch-action]\n  (match signal\n         :on-start nil\n         :on-stop nil\n\n         :on-increment\n         (dispatch-action :increment)\n\n         :on-decrement\n         (dispatch-action :decrement)\n\n         :on-increment-if-odd\n         (when (odd? (:val @model))\n           (dispatch-action :increment))\n\n         :on-increment-async\n         (.setTimeout js/window #(dispatch-action :increment) 1000)))\n\n(defn -on-action\n  [model action]\n  (match action\n         :increment (update model :val inc)\n         :decrement (update model :val dec)))\n\n(def blueprint {:initial-model -initial-model\n                :on-signal     -on-signal\n                :on-action     -on-action})", 
            "title": "Example (counter app)"
        }, 
        {
            "location": "/#packages", 
            "text": "", 
            "title": "Packages"
        }, 
        {
            "location": "/#ui-bindings", 
            "text": "carry-reagent \n(bindings for  Reagent )", 
            "title": "UI Bindings"
        }, 
        {
            "location": "/#middleware", 
            "text": "carry-atom-sync \n(creating a bidirectional sync between an app model and a specified atom-like reference)  carry-debugger \n(time traveling debugger)  carry-history \n(working with browser history)  carry-logging \n(console logging)  carry-persistence \n(automatic model saving/loading using browser storage)  carry-schema \n(model validation using  Schema )", 
            "title": "Middleware"
        }, 
        {
            "location": "/#documentation", 
            "text": "More information can be found at  the project site :   User Guide  Examples  API Reference  FAQ  Developer Guide", 
            "title": "Documentation"
        }, 
        {
            "location": "/#license", 
            "text": "Copyright \u00a9 2016 Yuri Govorushchenko.  Released under an MIT license.", 
            "title": "License"
        }, 
        {
            "location": "/user-guide/", 
            "text": "Basic\n\n\nCarry is actually a \nvery small\n\nClojure/ClojureScript state management library which provides a skeleton for the whole application.\n\n\nThe library is distributed via \nClojars\n and has no dependencies.\n\n\nAll the additional features (debugging, UI binding, etc.) are not part of the core project\nand can be provided by third-party packages. \nSome of them\n are already implemented\nand hosted in Carry repo \ncontrib folder\n.\nMost of these packages are implemented using \nCarry middleware pattern\n.\n\n\nThe private/internal API uses \n-\n prefix and should not be used (e.g. \n-this-is-some-private-thing\n).\n\n\nApp\n\n\nIn a Carry application all the code you write is encapsulated behind a single \napp\n instance. \nAn app is a map with keys:\n\n\n\n\n:model\n - an in-memory representation of an app state\n\n\n:dispatch-signal\n - a function for interaction with an app\n\n\n\n\nOne can consider an app to be a black box which exposes its current state and modifies it on getting signals from an external world.\nIt can also affect an external world as a response to a signal, i.e. perform \"side effects\".\n\n\nModel\n\n\nModel represents an entire state of an app. \n\n\nOne can access app's model via \n:model\n key to obtain an object that can be dereferenced and watched.\nAn exception will be thrown on mutating such read-only reference:\n\n\n(def my-model (:model my-app))\n\n; Dereference to get model value.\n@my-model\n;=\n {...}\n\n; Start reacting to model changes.\n(add-watch my-model :my-watch\n           (fn [_key _ref old-state new-state]\n             (when (not= old-state new-state)\n               (println \nmodel value has changed!\n))))\n\n((:dispatch-signal my-app) some-model-changing-signal)\n;=\n model value has changed!\n\n; Stop watching.\n(remove-watch my-model :my-watch)\n\n; It's impossible to directly mutate a model.\n(reset! my-model {:foo :bar})\n;=\n Error: ...\n\n\n\n\nCarry requires a model value to be a map. This convention allows writing reusable packages that can store additional data into any Carry app.\nAs an example, \ncarry-history\n adds \n:token\n to a model.\n\n\nSignals\n\n\nSignal\n is an object which represents a user's intention or, looking at it from a different angle, a system event. \nSignal can be synchronously sent to an app by calling its \ndispatch-signal\n function:\n\n\n((:dispatch-signal my-app) my-signal)\n\n\n\n\ndispatch-signal\n always returns \nnil\n.\n\n\nCarry accepts signals of any type. But usually signal is a just keyword with \"on-\" prefix or\na serializable vector with a keyword and an additional payload:\n\n\n:on-clear-completed\n[:on-update-todo id val]\n[:carry-history.core/on-enter token]\n\n\n\n\nUsing prefixes is recommended because it helps distinguish signal names from action names.\n\n\nCreating an App\n\n\nIn order to create an instance of a Carry app a user has to pass a \nblueprint\n into \napp\n function:\n\n\n(let [my-app (carry/app my-blueprint)]\n  ; ...\n  )\n\n\n\n\nA blueprint is a map with keys:\n\n\n\n\n:initial-model\n - an initial model value\n\n\n:on-signal\n - a function for handling signals\n\n\n:on-action\n - a function for handling actions\n\n\n\n\nIn other words, a blueprint is needed to define a runtime behavior of an app:\n\n\n\n\nSignal Handler\n\n\nSignal handler\n is a part of an application responsible for processing incoming signals. \nIt can dispatch new signals, modify app model (by dispatching actions) and perform any side effects (e.g. send data to a server).\nIt is free to contain an asynchronous code. The signature of a signal handler function:\n\n\n(defn on-signal\n  [model signal dispatch-signal dispatch-action])\n\n\n\n\n\n\nmodel\n - a read-only reference, the same as app's \n:model\n\n\nsignal\n - an incoming signal \n\n\ndispatch-signal\n - a synchronous function for dispatching new signals, the same as app's \n:dispatch-signal\n, can return some value\n\n\ndispatch-action\n - a synchronous function for modifying a model, always returns \nnil\n\n\n\n\nBy convention, signal handler should be able to at least handle \n:on-start\n and \n:on-stop\n signals.\nAs we'll see later, it's required by middleware with setup/teardown logic and to support hot reloading.\n\n\nIt is convenient (but not required) to use \npattern matching\n \nto switch between signals and destructure signals with payload.\nAs an example, this is a handler from \nfriend-list\n demo app:\n\n\n(ns friend-list.core\n  (:require [carry-history.core :as h]\n            ; ...\n            [goog.functions :refer [debounce]]\n            [cljs.core.match :refer-macros [match]]))\n\n; It's recommended to create a factory function if signal handler uses external dependencies.\n; It makes code more decoupled and \n; easier to unit test (stubs/mocks can be easily used instead of real implementations).\n; In this example browser history manager and API client are external dependencies.\n(defn -new-on-signal\n  [history api-search]\n  ; Some helper functions.\n  ; On successful search a new :on-search-success signal will be dispatched.\n  (let [search (fn [q dispatch-signal] (api-search q #(dispatch-signal [:on-search-success q %])))\n        search-on-input (debounce (fn [q dispatch-signal]\n                                    (h/push-token history q)\n                                    (search q dispatch-signal))\n                                  300)]\n    ; Function name is specified for better stacktraces.\n    (fn on-signal\n      [model signal dispatch-signal dispatch-action]\n      (match signal\n             ; This application has no custom setup/teardown logic\n             ; so just return nil on standard signals:             \n             :on-start nil\n             :on-stop nil\n\n             ; Signal destructuring example \n             [:on-input q]\n             (do\n               ; Update model.\n               (dispatch-action [:set-query q])\n\n               ; Begin (possibly async) searching.\n               (search-on-input q dispatch-signal))\n\n             ; ...\n\n             [:on-search-success q friends]\n             ; Note that model has to be dereferenced to get its value.\n             (if (= (:query @model) q)\n               (dispatch-action [:set-friends friends])\n               (println \nignore response for\n (pr-str q)\n                        \nbecause current query is\n (pr-str (:query @model))))))))\n\n; ...\n\n; Dependencies will be injected in a blueprint factory function:\n(defn new-blueprint\n  [history api-search]\n  {; ...\n   :on-signal (-new-on-signal history api-search)})\n\n; ...\n\n; Create and start an app using concrete dependencies.\n(def my-app (carry/app (new-blueprint my-history my-api-client)))\n((:dispatch-signal app) :on-start)\n\n\n\n\nYou're free to return any value from a signal handler. \nE.g. an asynchronous signal can return a \ncore.async\n channel or a promise\nso that other code can wait for it.\n\n\nActions\n\n\nAction\n is an object which represents an intention to modify a model.\nActions can be dispatched only from within a signal handler via \ndispatch-action\n.\n\n\nSimilar to signals, actions are usually keywords or vectors, for instance:\n\n\n:increment\n[:set-query q]\n\n\n\n\nAction Handler\n\n\nAction handler\n is a part of an application responsible for processing incoming actions.\nIt's a pure function which returns a new model value based on a current model value and an incoming action.\nOn getting an action an app passes it into a action handler and then resets app model value with the result.\n\n\nA simple example from \nfriend-list\n demo app:\n\n\n(defn -on-action\n  [model action]\n  (match action\n         [:set-query q]\n         (assoc model :query q)\n\n         [:set-friends friends]\n         (assoc model :friends friends)))\n\n\n\n\nIt's important to not put any asynchronous code, side effects or nondeterministic code (e.g. random number generation)\ninto action handler. Otherwise, it will make replaying actions unpredictable and break time traveling debugging.\n\n\nUsage with Reagent\n\n\nCarry can work with any view layer that is able to re-render UI in response to app model changes.\nThis chapter is about tying Carry with \nReagent\n \n(a ClojureScript wrapper for \nReact\n)\nusing \ncarry-reagent\n package: \n\n\n(ns app.core\n  (:require [carry.core :as carry]\n            [carry-reagent.core :as carry-reagent]\n            [reagent.core :as r]))\n\n; ...\n\n; Define app view model and view:\n\n(defn my-view-model\n  [model]\n  ; define a view model...\n)\n\n(defn my-view\n  [view-model dispatch]\n  ; a Reagent component that uses data from a view-model and dispatches signals on events...\n)\n\n(let [; Create an app.\n      app (carry/app my-blueprint)\n\n      ; \nConnect\n app, view model and view to create a Reagent component.\n      [_ app-view] (carry-reagent/connect app my-view-model my-view)]\n    ; Render component into DOM.\n    (r/render app-view (.getElementById js/document \nroot\n))\n\n    ; ...\n)\n\n\n\n\nApp view is constructed using \ncarry-reagent.core/connect\n function:\n\n\n(connect [app view-model view])\n\n\n\n\n\n\napp\n - Carry app instance\n\n\nview-model\n - a function which produces a view model\n\n\nview\n - a Reagent component\n\n\nreturns a pair \n[view-model-instance view-component]\n (view model is returned mainly for debugging)\n\n\n\n\nview-model\n function is called once on \nconnect\n call.\nThen returned view model instance is passed as an argument into \nview\n function to produce a final view component.\nA view thereby listens to a view model that in turn listens to a model:\n\n\n\n\nIn the next section we'll see how to define a view model.\n\n\nView Model\n\n\nView model\n contains all the data needed to render a UI.\nIt can compute derived model data, split lists of objects into pages, calculate which buttons are enabled, \ndetermine which app page to show depending on current URL, etc.\n\n\nUsually view model is a map of Reagent reactions. An example from \nTodoMVC\n app:\n\n\n(ns app.view-model\n  (:require ; ...\n            [carry-reagent.core :as carry-reagent]\n            [reagent.ratom :refer [reaction]]))\n\n(defn view-model\n  [model]\n  (let [; ...\n        ; Wrap todo items in a reaction.\n        all-todos (reaction (:todos @model))]\n    (-\n model\n        ; This helper function call will return {:field (reaction (:field @model))} map\n        ; (:field contains the value of a new todo input field).\n        (carry-reagent/track-keys [:field])\n\n        ; Additional view model fields are reactions \n        ; which will be recalculated if (and only if) all-todos value changes:\n        (assoc :has-todos? (reaction (-\n @all-todos count pos?))\n               :all-completed? (reaction (every? :completed? @all-todos))\n               ; ...\n               ))))\n\n\n\n\nArgument \nmodel\n is a \nReagent reaction\n that tracks app model changes.\nReaction is a special reference-like object that is created using Reagent's \nreaction\n macro.\nIt is lazily computed from other reactions and Reagent atoms\n(see \nofficial documentation\n for more information about Reagent atoms).\nAny Reagent component that dereferences a reaction is going to be automatically re-rendered when reaction value updates.\n\n\nView\n\n\nAn example from \nTodoMVC\n app:\n\n\n; A plain Reagent component which is redrawn when input arguments change.\n(defn -header\n  [field dispatch]\n  ; Reagent uses Hiccup-like syntax for defining HTML.\n  [:header.header\n   [:h1 \ntodos\n]\n\n   ; Input value is equal to field arg value.\n   [:input.new-todo {:placeholder \nWhat needs to be done?\n\n                     :value       field\n\n                     ; Dispatch signals on input events.\n                     :on-change   #(dispatch [:on-update-field (.. % -target -value)])\n                     :on-key-down #(when (-enter-key? %) (dispatch :on-add))}]])\n\n; Top app component that is passed into connect function.\n(defn view\n  ; Destructure view model map for cleaner code in the function body.\n  [{:keys [field has-todos? all-completed?\n           ; ...\n           ] :as _view-model}\n   dispatch]\n  [:section.todoapp\n   ; Deref |field| reaction to get its value for rendering.\n   ; Derefing also makes parent component start watching for |field| changes \n   ; so that -header will be re-rendered on |field| updates. \n   [-header @field dispatch]\n\n   ; ...\n   ]))\n\n\n\n\nAs you can see, we get reactions from a view model and deref them to render actual values.\nReagent will then \"magically\" re-render components when the reactions passed into them are updated.\n\n\nUsage with Figwheel and REPL\n\n\nWith \nFigwheel\n Leiningen plugin it is possible to:\n\n\n\n\ncompile and reload app code in browser on source code changes\n\n\ncommunicate with a running app via REPL\n\n\n\n\nMost of Carry \nexamples\n use Figwheel for development builds and \nrely on the \"bare\" \nlein-cljsbuild\n for production builds.\n\n\nThe main thing to remember is to stop the currently running app before hot reload \nin order to unsubscribe it from browser events and free memory.\nHere's how you can structure your main app file to be used with Figwheel: \n\n\n(ns app.core\n  (:require [carry.core :as carry]\n            [carry-reagent.core :as carry-reagent]\n            [reagent.core :as r]))\n\n; ...\n\n(defn main\n  []\n  (let [app (carry/app my-blueprint)\n        [app-view-model app-view] (carry-reagent/connect app my-view-model my-view)]\n    (r/render app-view (.getElementById js/document \nroot\n))\n\n    ; Start the app.\n    ((:dispatch-signal app) :on-start)\n\n    ; For debugging purposes add view-model into returned map.\n    (assoc app :view-model app-view-model)))\n\n; Start new app and save it into the global var for debugging in REPL.\n(def app (main))\n\n;;;;;;;;;;;;;;;;;;;;;;;; Figwheel stuff\n; These functions should be specified in project.clj :figwheel map.\n\n; Stop current app before loading a new one.\n(defn before-jsload\n  []\n  ((:dispatch-signal app) :on-stop))\n\n(defn on-jsload\n  []\n  #_(. js/console clear))\n\n\n\n\nTo get an interactive development environment run:\n\n\nlein figwheel\n\n\n\n\nor better:\n\n\nrlwrap lein figwheel\n\n\n\n\nand open your browser at \nlocalhost:3449\n.\nThis will auto compile and send all changes to the browser without the\nneed to reload. After the compilation process is complete, you will\nget a Browser Connected REPL. An easy way to try it is:\n\n\n(js/alert \nAm I connected?\n)\n\n\n\n\nand you should see an alert in the browser window.\n\n\nYou can also directly access \napp\n map from REPL:\n\n\ncljs.user=\n (ns app.core)\nnil\n\napp.core=\n (keys app)\n(:model :dispatch-signal :view-model)\n\napp.core=\n @(:model app)\n{...}\n\napp.core=\n ((:dispatch-signal app) :on-increment)\nnil\n\n\n\n\nYou may also want to directly modify the app model in REPL without dispatching signals/actions.\nThis can be achieved by using \ncarry-atom-sync\n middleware\nto create a helper \"model atom\" specifically for debugging in REPL. An example from \nTodoMVC\n:\n\n\n(ns app.core\n  (:require [app.blueprint :as blueprint]\n            [carry-atom-sync.core :as atom-sync]\n            ; ...\n            )) \n; ...\n\n; \nModel atom\n exposed for debugging in REPL.\n(def model (atom nil))\n\n(defn main\n  []\n  (let [blueprint (-\n (blueprint/new-blueprint ...)\n                       ; ...\n                       ; Apply middleware to setup a sync with \nmodel atom\n.\n                       (atom-sync/add model))\n        app (carry/app blueprint)\n        ; ...\n        ]\n    ; ...\n    ((:dispatch-signal app) :on-start)\n    ; ...\n    ))\n\n; ...\n\n\n\n\nNow after app is started you can directly work with app model via \nmodel\n atom in REPL:\n\n\napp.core=\n (cljs.pprint/pprint (dissoc @model :carry-debugger.core/debugger))\n{:field \n,\n :todos\n ({:id 0,\n   :title \nFinish this project\n,\n   :completed? false,\n   :original-title \n,\n   :editing? false}\n  {:id 1,\n   :title \nTake a bath\n,\n   :completed? true,\n   :original-title \n,\n   :editing? false}), \n :next-id 2, \n :carry-history.core/token \n}\n\napp.core=\n (swap! model assoc :field \nfoobar\n)\n{:field \nfoobar\n, ...}\n\napp.core=\n (= @model @(:model app))\ntrue\n\n\n\n\nAdvanced\n\n\nMiddleware\n\n\nMiddleware\n is a function that gets an app blueprint and returns an updated blueprint\nin order to introduce some new app behavior (such as logging, syncing with server, crash reporting).\n\n\n\n\n Also see: \nready-to-use middleware packages\n.\n\n\n\n\nMultiple middleware can be applied in a chain to produce a new blueprint.\nFor instance, \nTodoMVC\n app blueprint is wrapped by three middleware:\n\n\n(defn new-blueprint\n  [history storage storage-key todo-titles]\n  (-\n {:initial-model (model/new-model todo-titles)\n       :on-signal     on-signal\n       :on-action     on-action}\n\n      ; 1\n      (schema/add model/Schema)\n\n      ; 2\n      (persistence/add storage storage-key {:blacklist #{::h/token}})\n\n      ; 3\n      (h/add history)))\n\n\n\n\nAn order in which middleware are applied matters. One can think of it as an onion: each middleware is a layer that wraps a blueprint\nand handles bypassing signals and actions:\n\n\n\n\nAs an example, this is a simple middleware which logs all actions and signals coming through an app:\n\n\n(ns carry-logging.core\n  (:require))\n\n(defn add\n  \nWill print all signals and actions to console using the specified prefix string.\n\n  ([blueprint] (add blueprint \n))\n  ([blueprint prefix]\n   (-\n blueprint\n       ; Wrap signal handler to log signals.\n       (update :on-signal\n               (fn wrap-on-signal [app-on-signal]\n                 (fn on-signal [model signal dispatch-signal dispatch-action]\n                   (try\n                     ; Log.\n                     (.group js/console (str prefix \nsignal \n (pr-str signal)))\n\n                     ; Let app handle the signal.\n                     (app-on-signal model signal dispatch-signal dispatch-action)\n\n                     ; this clause guarantees that group is closed even in case of exception\n                     (finally\n                       (.groupEnd js/console))))))\n\n       ; Wrap action handler to log actions.\n       (update :on-action\n               (fn wrap-on-action [app-on-action]\n                 (fn on-action [model action]\n                   ; Log.\n                   (.log js/console (str prefix \naction\n) (pr-str action))\n\n                   ; Let app handle the action.\n                   (app-on-action model action)))))))\n\n\n\n\nMore complex middleware can:\n\n\n\n\nModify initial model.\n\n\nIntercept \n:on-start\n/\n:on-stop\n signals.\n\n\nDispatch new signals and actions to an app.\nBy convention, they must use namespaced keywords (e.g. \n:my-middlware.core/on-something\n) to prevent a name clash with other signals.\n\n\nDispatch \"own\" signals and actions (also namespaced) which should not be handled by a wrapped app.\n\n\nSubscribe to model changes.\n\n\nHave injected dependencies.\n\n\n\n\nAll these cases are demonstrated by \ncarry-history\n middleware:\n\n\n(ns carry-history.core\n  ; ...\n)\n\n(defn -wrap-initial-model\n  [app-initial-model]\n  (merge {::token \n/\n} app-initial-model))\n\n; History will be injected on applying the middleware.\n(defn -wrap-on-signal\n  [app-on-signal history]\n  (let [unlisten (atom nil)]\n    (fn on-signal\n      [model signal dispatch-signal dispatch-action]\n      (match signal\n             ; Intercept :on-start signal.\n             :on-start\n             ; Let the wrapped app start first.\n             (let [original-signal-result (app-on-signal model signal dispatch-signal dispatch-action)]\n               ; Start listening to model updates.\n               (add-watch model ::token-watch\n                          (fn [_key _ref old-state new-state]\n                            ; ...\n                            ))\n\n               ; Start listening to history events.\n               (reset! unlisten\n                       (listen history #(dispatch-signal [::on-history-event ; ...\n                                                          ])))\n\n               ; ...      \n\n               ; Preserve the return value of the wrapped signal.\n               original-signal-result)\n\n      ; Intercept clean up signal.\n      :on-stop\n      (do\n        ; Unsubscribe from history events. \n        ; Otherwise, on hot reload unused listeners will stay in memory.\n        (@unlisten)\n\n        ; There's no need to remove model watches on hot reload \n        ; because they will be garbage-collected with the model.\n\n        ; Let the wrapped app continue cleaning up.\n        (app-on-signal model signal dispatch-signal dispatch-action))\n\n      ; Middleware-specific signal that will not be passed further to an app.\n      [::on-history-event {:token token :browser-event? browser-event? :event-data event-data}]\n      (do\n        ; Dispatch a middleware-specific action.\n        (dispatch-action [::set-token token])\n\n        (when (or browser-event? (:treat-as-browser-event? event-data))\n          ; Dispatch a signal to an app.\n          (dispatch-signal [::on-enter token])))\n\n      ; Pass other signals further.\n      :else\n      (app-on-signal model signal dispatch-signal dispatch-action)))))\n\n(defn -wrap-on-action\n  [app-on-action]\n  (fn on-action\n    [model action]\n    (match action\n           ; A middleware-specific action.\n           [::set-token token]\n           (assoc model ::token token)\n\n           ; Pass other actions further.\n           :else\n           (app-on-action model action))))\n\n; History is an injected dependency.\n(defn add\n  [blueprint history]\n  (-\n blueprint\n      (update :initial-model -wrap-initial-model)\n      (update :on-signal -wrap-on-signal history)\n      (update :on-action -wrap-on-action)))\n\n\n\n\nEspecially note how \n:on-start\n/\n:on-stop\n signals are intercepted:\n\n\n\n\nThe middleware let's the wrapped app start first and then runs its own additional initialization code.\nIt doesn't modify the return value of the underlying signal handler.\n\n\nThe order is \"reversed\" on stopping: the middleware first cleans up after itself and only then let's the wrapped app shutdown.\n\n\n\n\nDebugger\n\n\nOne of the main features of Carry pattern is that it allows time traveling debugging\nsimilar to \nElm's Debugger\n,\n\nRedux DevTools\n and \nCerebral Debugger\n.\n\n\nCarry has its own visual time traveling debugger with next features:\n\n\n\n\nDebugger records all app signals and actions and shows them as a tree.\n\n\nA signal is displayed as a respective tree leaf if it's dispatched from inside another signal.\n\n\nDebugger records results of every action so that every past model value can be logged to console.\n\n\nAny action can be disabled/enabled. On toggling an action debugger will reset app model \nto its initial value and \nreplay\n all enabled actions.\nThis way user can immediately see how the app would look like if the action never took place.\nAction replaying is possible because actions are always pure and change app model in a predictable way.\nOn the other hand, it's impossible to predictably replay signals as they can perform async side effects.\n\n\nClicking a signal toggles all its child actions.\n\n\nClicking \"Replay\" button enables debugger's \"replay mode\" and marks already recorded actions as \"to be replayed\".\nThese actions are saved into local storage and will be automatically replayed on next app start.\nIn combination with Figwheel hot reloading this allows editing action handling code\nand immediately see how it affects a final app state (effectively \"changing the past\").\n\n\nDebugging session can be saved into a file and then loaded.\n\n\n\"Clear\" button removes all recorded signals and actions without modifying current app state.\n\n\n\"Vacuum\" removes all disabled actions and \"dangling\" signals without enabled actions.\n\n\n\"Reset\" resets an app to its initial state and clears recorded signals and actions.\n\n\nCurrently debugger uses Reagent+jQuery UI to render a resizable overlay view.\n\n\n\n\n\n  \n\n\n\n\nTo use a debugger developer has to apply \ncarry-debugger\n middleware,\nconnect a debugger view and render it alongside an app view:\n\n\n(ns app.core\n  (:require [carry.core :as carry]\n            [carry-reagent.core :as carry-reagent]\n            [carry-debugger.core :as debugger]\n            [reagent.core :as r]\n            [hodgepodge.core :as hp]\n            ; ...\n            ))\n\n; ...\n\n(defn main\n  []\n  (let [; Use hodgepodge lib for dealing with browser's local storage.\n        storage hp/local-storage\n\n        ; Apply middleware.\n        app-blueprint (-\n my-blueprint\n                          ; Middleware requires a storage and a unique storage key.\n                          (debugger/add storage :my-debugger-model))\n\n        ; App and UI.\n        app (carry/app app-blueprint)\n        [_ app-view] (carry-reagent/connect app my-view-model my-view)\n\n        ; Connect debugger UI.\n        [_ debugger-view] (debugger/connect app)]\n    ; Render app and debugger views.\n    (r/render [:div app-view debugger-view] (.getElementById js/document \nroot\n))\n\n    ; Start.\n    ((:dispatch-signal app) :on-start)\n\n    ; ...\n    ))\n\n\n\n\nFor correct rendering debugger also requires jQuery UI CSS to be injected into HTML.\nPlease see \nAPI reference\n for more info.\n\n\nThere are cases when you'd like to check if debugger is in replay mode.\nFor instance, \ncarry-history\n\nmiddleware doesn't send its initial \n:on-enter\n signal in replay mode.\nSuch behavior makes live coding more pleasant as developer expects only marked actions to be replayed on app start.\nDebugger mode can be determined by looking at \n[:carry-debugger.core/debugger :replay-mode?]\n path in a model map:\n\n\n(ns carry-history.core\n  ; ...\n  )\n\n; ...\n\n(defn -wrap-on-signal\n  [app-on-signal history]\n  (let [unlisten (atom nil)]\n    (fn on-signal\n      [model signal dispatch-signal dispatch-action]\n      (match signal\n             :on-start\n             (do\n               (app-on-signal model signal dispatch-signal dispatch-action)\n\n               ; ...\n\n               ; Check if we're in replay mode before sending an initial signal\n               (when (not (-\n @model :carry-debugger.core/debugger :replay-mode?))\n                 (dispatch-signal [; ... \n                                   ])))\n             ; ...\n             ))))\n; ...\n\n\n\n\nUnit Testing\n\n\nIt is comparatively easy to unit test a Carry app\nwith Reagent bindings because its behavior is implemented in four functions with explicit dependencies:\n\non-signal\n, \non-action\n, \nview-model\n, \nview\n.\n\n\nLet's look at how these functions are tested in\n\nfriend-list\n example:\n\n\non-signal\n\n\n\n(on-signal model signal dispatch-signal dispatch-action)\n\n\n\n\nSignal handler receives incoming signals to perform side effects, dispatch new signals and actions.\nSuch behavior is easy to test using \nmock\n functions.\nThis test uses \nclj-fakes\n \nisolation framework for recording and checking \ndispatch-signal\n and \ndispatch-action\n calls\non receiving \n:on-enter\n signal:\n\n\n(ns unit.signals\n  (:require\n    [friend-list.core :as friend-list]\n    [carry.core :as carry]\n    [carry-history.core :as h]\n    [clojure.test :refer [deftest is testing]]\n    [clj-fakes.core :as f]\n    ;...\n    ))\n\n(deftest\n  on-navigation-updates-query-and-searches\n  (f/with-fakes\n    (let [search (f/fake [[:_new-token (f/arg ifn?)] #(%2 :_found-friends)])\n          {:keys [on-signal]} (friend-list/new-blueprint :_history search)\n          dispatch-signal (f/recorded-fake)\n          dispatch-action (f/recorded-fake)]\n      ; act\n      (on-signal :_model [::h/on-enter :_new-token] dispatch-signal dispatch-action)\n\n      ; assert\n      (is (f/was-called-once dispatch-action [[:set-query :_new-token]]))\n      (is (f/was-called-once dispatch-signal [[:on-search-success :_new-token :_found-friends]])))))\n\n\n\n\n\n\n\n\nTest is written using \nArrange-Act-Assert (AAA)\n pattern.\nComments are added to better separate these logical blocks.\n\n\n\n\n\n\nSignal handler is taken from the blueprint created by \nfriend-list/new-blueprint\n.\nIt could be tempting to instead test by using \nfriend-list/-new-on-signal\n helper function.\nBut accessing private members is a bad practice\nand there can also be middleware applied inside \nnew-blueprint\n which can affect the tested behavior. Thus:\n\n\n\n\n\n\n{:keys [on-signal]} (friend-list/new-blueprint :_history search)\n\n\n\n\n\n\nInstead of using a real async API client we create a fake \nsearch\n \nfunction which synchronously returns the expected result and \nwill throw an exception on calls with unexpected arguments:\n\n\n\n\nsearch (f/fake [[:_new-token (f/arg ifn?)] #(%2 :_found-friends)])\n\n\n\n\n\n\nDynamic nature of ClojureScript allows us to use keywords (\n:_history\n, \n:_found-friends\n, \n:_model\n, \n:_new_token\n) instead\nof creating objects of correct type when we know that their type doesn't really matter in the test case.\nIt makes tests more focused and readable.\nThis technique is similar to \nusing metaconstants in Midje\n.\n\n\n\n\non-action\n\n\n\n(on-action model action)\n\n\n\n\nAction handler is the easiest function to test because it's pure:\n\n\n(deftest\n  sets-query\n  (let [{:keys [initial-model on-action]} (friend-list/new-blueprint :_history :_search)]\n    (is (= \nnew query\n\n           (:query (on-action initial-model [:set-query \nnew query\n]))))))\n\n\n\n\nHere again we first create a blueprint in order to get \ninitial-model\n value and \non-action\n function.\n\n\nNotice that it's impossible to use \n:_new_query\n \"metaconstant\" because app uses \n\ncarry-schema\n\nmiddleware forcing us to use a string value \n\"new-query\"\n on action handling.\n\n\nview-model\n\n\n\n(view-model model)\n\n\n\n\nThese tests make sure that view model really contains Reagent reactions\nat \n:query\n and \n:friends\n keys:\n\n\n(ns unit.view-model\n  (:require\n    [friend-list.core :as friend-list]\n    [reagent.core :as r]\n    [reagent.ratom :refer [run! reaction]]\n    [schema-generators.generators :as g]\n    [clojure.test :refer [deftest is]]))\n\n(defn test-view-model-tracks-model-key\n  [model-key action expected-view-model-value]\n  (let [{:keys [initial-model on-action]} (friend-list/new-blueprint :_history :_search)\n        model (r/atom initial-model)\n        view-model (friend-list/view-model (reaction @model))\n        witness (atom nil)]\n    (is (contains? view-model model-key) \nself-test\n)\n    (run! (reset! witness @(model-key view-model)))\n\n    ; act\n    (swap! model on-action action)\n\n    ; force reaction updates\n    (r/flush)\n\n    ; assert\n    (is (= expected-view-model-value @witness))))\n\n(deftest\n  tracks-query\n  (test-view-model-tracks-model-key :query [:set-query \nnew query\n] \nnew query\n))\n\n(deftest\n  tracks-friends\n  (let [new-friends (g/sample 3 friend-list/Friend)]\n    (test-view-model-tracks-model-key :friends [:set-friends new-friends] new-friends)))\n\n\n\n\n\n\ntest-view-model-tracks-model-key\n is a helper function.\n\n\nr/flush\n is needed because Reagent doesn't immediately propagate reaction updates (starting from v0.6.0).\n\n\nschema-generators\n library is used to automatically generate\n\nnew-friends\n fixture instead of coding it by hand.\n\n\n\n\nview\n\n\n\n(view view-model dispatch)\n\n\n\n\n(This section is a WIP.)\n\n\nUnit testing this function is probably not critical because most error-prone UI\ncode is located in \nview-model\n.\n\n\nRouting\n\n\nIt's not uncommon for applications to depend on a current URL and modify it in response to user actions.\nFor these tasks \ncarry-history\n middleware\nprovides a bidirectional synchronization between a browser URL and a model:\n\n\n\n\nAn app can react to URL changes by observing model's \n:token\n (token, roughly, is everything that goes after a hostname).\n\n\nIf token in model is changed by an app then a browser will accordingly update its address bar.\nThis is especially useful during time traveling debugging as toggling token-changing actions will correctly update a URL.\n\n\n\n\n\n\n Examples:\n\n\n\n\nFriend List\n - in this application a token is synced with a search query.\n\n\nTodoMVC\n - here \nSilk\n routing library is added to parse and build tokens.\n\n\n\n\n\n\nUse \nadd\n to apply the middleware\nand don't forget to start the app:\n\n\n(ns app.core\n  (:require [carry.core :as carry] \n            [carry-history.core :as h]\n            ; ...\n            ))\n\n; ...\n\n(let [history (h/new-hash-history)\n      app-blueprint (-\n my-blueprint\n                        (h/add history))\n      app (carry/app app-blueprint)\n      ; ...\n      ]\n    ((:dispatch-signal app) :on-start)\n    ; ...\n\n\n\n\nThe middleware requires a \nHistory API\n \nwrapper to be provided.\nSuch object must satisfy \nHistoryProtocol\n\nand there are several constructors for creating such instances:\n\n\n\n\n\n\n(new-legacy-hash-history)\n\n\n\n\n\n\n(new-hash-history)\n\n\n\n\n\n\n(new-history)\n\n\n\n\n\n\n\n\n carry-history uses \nGoogle Closure\n\nlibrary for interfacing with History API.\n\n\n\n\nA wrapped app can now react to token changes:\n\n\n(defn view-model\n  [model]\n  {:token (reaction (::h/token @model))})\n\n(defn view\n  [{:keys [token] :as _view-model} dispatch]\n  [:p \nCurrent token = \n (pr-str @token)])\n\n\n\n\nIt also becomes possible to react to token changes by handling \n::on-enter\n signal.\nIt will be dispatched on app start and on changes initiated by user actions (e.g. editing an address or clicking Back button):\n\n\n(match signal\n       [::h/on-enter token]\n       (println \nnavigated to page at \n (pr-str token))\n\n       ; ...\n\n\n\n\nPackage's \nlink\n Reagent component can be used to create in-app links which don't hit the server.\nAn example from \nTodoMVC\n:\n\n\n(defn -footer-filters\n  [visibility-config history]\n  [:ul.filters\n   (for [{:keys [title route selected?]} visibility-config]\n     ^{:key route}\n     [:li [h/link history (router/route-\ntoken route)\n           {:class (if selected? \nselected\n)}\n           title]])])\n\n\n\n\nPlease see \nAPI reference\n for more info.\n\n\nUsage with DataScript\n\n\nSee examples:\n\n\n\n\nCounter DataScript\n\n\nShopping Cart\n\n\n\n\nUsage with Devcards\n\n\nThis section describes how to make Carry work with \nDevcards\n for a \"visual REPL experience\".\nFurther I assume you have a basic understanding of Devcards and I won't focus on why it's needed, installation details, etc.\nWe'll see how to render Carry/Reagent app instances inside cards.\n\n\n\n\n This chapter is based on \ncounter-devcards\n example project.\n\n\n\n\nThis is a simplest card for the app which uses \ncarry-reagent\n for UI:\n\n\n\n  \n\n\n\n\n(ns app.core\n  (:require [counter.core :as counter]\n            [carry.core :as carry]\n            [carry-reagent.core :as carry-reagent]\n            [reagent.core :as r]\n            [devcards.core :refer-macros [defcard-rg]]))\n\n; ...\n\n(defcard-rg\n  counter\n  (let [app (carry/app counter/blueprint)\n        [_ app-view] (carry-reagent/connect app counter/view-model counter/view)]\n    app-view))\n\n\n\n\nHere \ndefcard-rg\n macro is used to render an app Reagent component.\nOn hot reload (e.g. via Figwheel) a new app will be created from scratch.\n\n\nThis example lacks dispatching standard \n:on-start\n/\n:on-stop\n signals, let's fix this:\n\n\n(defn -with-mount-callbacks\n  [_component on-did-mount on-will-unmount]\n  (r/create-class {:reagent-render         (fn [component _on-did-mount _on-will-unmount] component)\n                   :component-did-mount    (fn [_this] (on-did-mount))\n                   :component-will-unmount (fn [_this] (on-will-unmount))}))\n\n(defcard-rg\n  counter\n  (let [app (carry/app (-\n counter/blueprint\n                           (logging/add \n[counter] \n)))\n        [_ app-view] (carry-reagent/connect app counter/view-model counter/view)]\n\n    [-with-mount-callbacks\n     app-view\n     #((:dispatch-signal app) :on-start)\n     #((:dispatch-signal app) :on-stop)]))\n\n\n\n\nA helper Reagent component \n-with-mount-callbacks\n is created for starting the app after mounting and for stopping the app\nwhen the card component is going to unmount on hot reload. \n\n\nDevcards also has an ability to display a simple time traveling \"history\" widget to go back and forward between recorded\ncomponent state values (\ndemo\n):\n\n\n\n  \n\n\n\n\n(defcard bmi-calculator                        ;; optional symbol name\n  \n*Code taken from Reagent readme.*\n          ;; optional markdown doc\n  (fn [data-atom _] (bmi-component data-atom)) ;; object of focus\n  {:height 180 :weight 80}                     ;; optional initial data\n  {:inspect-data true :history true})          ;; optional devcard config options\n\n\n\n\nIt doesn't work out out-of-box with Carry because a Carry app has no ability to expose its underlying model atom to a card.\nTo solve this we use \ncarry-atom-sync\n middleware\nwhich creates a bidirectionally sync between the \"data atom\" created by Devcards and an app model:\n\n\n\n  \n\n\n\n\n(ns app.core\n  (:require [counter.core :as counter]\n            [carry.core :as carry]\n            [carry-atom-sync.core :as carry-atom-sync]\n            [carry-reagent.core :as carry-reagent]\n            [cljs.core.match :refer-macros [match]]\n            [devcards.core :refer-macros [defcard-rg]]))\n\n; ...\n\n(defcard-rg\n  counter-with-history\n  \nPreserves model value between hot reloads.\n\n  (fn [data-atom _]\n    ; Create app instance.\n    (let [app (carry/app (-\n counter/blueprint\n\n                             ; Get model value from data atom.\n                             (assoc :initial-model @data-atom)\n\n                             ; Setup bidirectional sync with data atom.\n                             (carry-atom-sync/add data-atom)\n\n                             (logging/add \n[counter-with-history] \n)))\n          [_ app-view] (carry-reagent/connect app counter/view-model counter/view)]\n      ; Render app view.\n      [-with-mount-callbacks\n       app-view\n\n       ; Start the app after mounting.\n       #((:dispatch-signal app) :on-start)\n\n       ; Stop the app on umount/hot-reload.\n       #((:dispatch-signal app) :on-stop)]))\n\n  ; Create data atom with initial model value.\n  (atom (:initial-model counter/blueprint))\n\n  ; Card options.\n  {:inspect-data true\n   :history      true})\n\n\n\n\nWhat's happening here:\n\n\n\n\nA new app instance is created on each hot reload.\n\n\nThe data atom is created once and then conveniently preserves its value between hot reloads.\n\n\nOn creation an app takes its initial value from the data atom.\n\n\nOn UI interactions all app model updates are propagated into the data atom enlarging the card's history stack.\n\n\nOn clicking history widget buttons the data atom is updated and its new values are synced back into the app model. \n\n\n\n\nOf course, if a lot of cards are created like this then extracting a \nhelper macro or function should be considered in order to reduce code duplication.\n\n\nNote that we must start the app only after mounting.\nOtherwise, starting app synchronously in a card function will produce\na \n\"setState(...): Cannot update during an existing state transition\"\n warning on hot reloads\n(because \ncarry-atom-sync\n middleware resets \ndata-atom\n):\n\n\n(defcard-rg\n  counter-with-history\n  (fn [data-atom _]\n   ; ...\n\n   ; Will produce a warning:\n   ((:dispatch-signal app) :on-start)   \n\n   [-with-mount-callbacks\n    app-view\n    ; ...\n    ])\n\n   ; ...\n  )\n\n\n\n\nFile Structure\n\n\nAs an application grows it starts making sense to organize its code using folders and files.\nLet's look at some examples of organizing a source folder.\n\n\nSplit by \"Layer\"\n\n\n\napp/\n  model.cljs \n-- initial model and its schema\n  signals.cljs \n-- signal handler\n  actions.cljs \n-- action handler\n  view_model.cljs\n  view.cljs\n  core.cljs\n\n\n\n\nCons:\n\n\n\n\nIt doesn't work well for several developers working on new features because everyone will touch most layers\nleading to frequent merge conflicts.\n\n\nWith time it will become harder to navigate the codebase with a few big files.\n\n\n\n\nSo the next step could be splitting each layer by feature and using folders:\n\n\napp/\n  signals/\n    foo.cljs\n    bar.cljs\n  actions/\n    foo.cljs\n    bar.cljs\n  ...\n  core.cljs\n\n\n\n\nThis way a developer working on \nfoo\n feature will have less VCS conflicts with a developer working on \nbar\n.\n\n\nSplit by \"Feature\"\n\n\n\nHere \nFoo\n and \nBar\n can correspond to application screens,\nbusiness logic domains or even single use cases\n(take a look at \n\"Screaming Architecture\"\n):\n\n\napp/\n  foo.cljs \n-- signals, actions and UI for Foo\n  bar.cljs \n-- signals, actions and UI for Bar\n  core.cljs\n\n\n\n\nLater we can split every feature by layer for easier navigation, e.g.:\n\n\napp/\n  foo/\n    model.cljs\n    signals.cljs\n    actions.cljs\n    view_model.cljs\n    view.cljs\n  bar/\n    model.cljs\n    signals.cljs\n    actions.cljs\n    view_model.cljs\n    view.cljs\n  core.cljs\n\n\n\n\nYou may also make coarser splits if layers are relatively small, for instance:\n\n\napp/\n  foo/\n    logic.cljs \n-- signals, actions and model go here\n    ui.cljs \n-- view and view-model go here\n  bar/\n    logic.cljs\n    ui.cljs\n  core.cljs\n\n\n\n\nConclusion\n\n\n\nThere are many ways to organize Carry application code and it's up to you to choose what works best for your project.\n\n\nBlueprint Splitting\n\n\nLet's take the project structure example mentioned earlier:\n\n\napp/\n  foo/\n    model.cljs\n    signals.cljs\n    actions.cljs\n    view_model.cljs\n    view.cljs\n  bar/\n    model.cljs\n    signals.cljs\n    actions.cljs\n    view_model.cljs\n    view.cljs\n  core.cljs\n\n\n\n\nHow to define a single Carry blueprint from the code scattered over all these files?\nIt is simple to merge all initial models to get a full model,\nbut there can be different ways to assemble handler functions:\n\n\n(def blueprint {:initial-model (merge app.foo.model/initial-model\n                                      app.bar.model/initial-model)\n                :signal-halder ??? \n                :action-handler ???}\n\n\n\n\nThere are two conceptual ways of splitting a handler:\n\n\n\n\nAt a level of \"cases\" (signals/actions):\n\n\n\n\napp/\n  foo/\n    signals.cljs \n-- handles signals :on-a, :on-b\n  bar/\n    signals.cljs \n-- handles signals :on-c, :on-d\n\n\n\n\n\n\nCode for each individual signal/action can also be split between files:\n\n\n\n\napp/\n  foo/\n    signals.cljs \n-- handles :on-a and partially :on-b\n  bar/\n    signals.cljs \n-- handles :on-c, :on-d and partially :on-b\n\n\n\n\nWhich approach is better? There's no definite answer. For instance, take a look at the discussions about the similar problem in Flux/Redux:\n\n\n\n\nProblems with Flux\n\n\nRedux issue #1400\n\n\n\n\nWe'll see how to implement the first, stricter and simpler, approach and \nleave implementing the second approach as an exercise to the reader.\n\n\nHOF\n\n\n\nOne of the solutions is to use a higher-order function (HOF) \ndispatching-to-either\n\nwhich will assemble a handler (see \nexample\n):\n\n\n(ns app.utils)\n\n(defn dispatching-to-either\n  \nReturns a function of any args which calls functions one by one while :cant-handle is returned.\n\n  [fns]\n  (fn dispatching-to-either-fn [\n args]\n    (loop [f (first fns)\n           next-fns (rest fns)]\n      (when (nil? f)\n        (throw (ex-info (str \nNo function was able to handle passed args: \n (pr-str args))\n                        {})))\n\n      (let [result (apply f args)]\n        (if (= result :cant-handle)\n          (recur (first next-fns) (rest next-fns))\n          result)))))\n\n\n\n\n(ns app.common.signals\n  (:require [cljs.core.match :refer-macros [match]]))\n\n(defn on-signal\n  [_model signal _dispatch-signal dispatch-action]\n  (match signal\n         :on-start nil\n         :on-stop nil\n         :on-home (dispatch-action [:navigate :home])\n         :on-settings (dispatch-action [:navigate :settings])\n         :else :cant-handle))\n\n\n\n\n(ns app.home.signals\n  (:require [cljs.core.match :refer-macros [match]]))\n\n(defn on-signal\n  [_model signal _dispatch-signal dispatch-action]\n  (match signal\n         :on-click (dispatch-action :click)\n         :else :cant-handle))\n\n\n\n\n(ns app.blueprint\n  (:require [app.common.model]\n            [app.common.signals]\n            [app.common.actions]\n\n            [app.home.model]\n            [app.home.signals]\n            [app.home.actions]\n\n            [app.settings.model]\n            [app.settings.signals]\n            [app.settings.actions]\n\n            [app.utils]))\n\n(def blueprint {:initial-model (merge app.common.model/initial-model\n                                      app.home.model/initial-model\n                                      app.settings.model/initial-model)\n                :on-signal     (app.utils/dispatching-to-either #{app.common.signals/on-signal\n                                                                  app.home.signals/on-signal\n                                                                  app.settings.signals/on-signal})\n                :on-action     (app.utils/dispatching-to-either #{app.common.actions/on-action\n                                                                  app.home.actions/on-action\n                                                                  app.settings.actions/on-action})})\n\n\n\n\nThe drawback of this solution is that a blueprint must be edited every time a new handler file is added.\n\n\nMultimethods\n\n\n\nMultimethods can help by allowing to not type the names of all the handlers manually (see \nexample\n):\n\n\n(ns app.blueprint\n  (:require [app.common.model]\n            [app.common.actions]\n            [app.common.signals]\n\n            [app.home.model]\n            [app.home.actions]\n            [app.home.signals]\n\n            [app.settings.model]\n            [app.settings.actions]\n            [app.settings.signals]\n\n            [app.blueprint-methods]))\n\n(def blueprint {:initial-model (merge app.common.model/initial-model\n                                      app.home.model/initial-model\n                                      app.settings.model/initial-model)\n\n                ; Voil\u00e0:\n                :on-signal     app.blueprint-methods/on-signal\n                :on-action     app.blueprint-methods/on-action})\n\n\n\n\n(ns app.common.signals\n  (:require [app.blueprint-methods :refer [on-signal]]))\n\n(defmethod on-signal :on-start\n  [_model _ _dispatch-signal _dispatch-action]\n  nil)\n\n(defmethod on-signal :on-stop\n  [_model _ _dispatch-signal _dispatch-action]\n  nil)\n\n(defmethod on-signal :on-home\n  [_model _ _dispatch-signal dispatch-action]\n  (dispatch-action [:navigate :home]))\n\n(defmethod on-signal :on-settings\n  [_model _ _dispatch-signal dispatch-action]\n  (dispatch-action [:navigate :settings]))\n\n\n\n\n(ns app.common.actions\n  (:require [app.blueprint-methods :refer [on-action]]))\n\n(defmethod on-action :navigate\n  [model [_ pane]]\n  (assoc model :pane pane))\n\n\n\n\n(ns app.blueprint-methods)\n\n(defn -tag\n  \nReturns a tag of a variant (read http://jneen.net/posts/2014-11-23-clojure-conj-variants-errata). Examples:\n  [:foo :bar] -\n :foo\n  [:foo] -\n :foo\n  :foo -\n :foo\n\n  [variant]\n  (if (sequential? variant)\n    (first variant)\n    variant))\n\n(defmulti on-signal (fn [_model signal _dispatch-signal _dispatch-action]\n                      (-tag signal)))\n\n(defmulti on-action (fn [_model action]\n                      (-tag action)))\n\n\n\n\nUnfortunately, now there's more cruft in handler files. It's especially obvious in \napp.common.signals\n listing.\n\n\nMultimethods and core.match\n\n\n\nLet's try to reduce boilerplate by grouping events with the same namespace and using \ncore.match\n\n(see \nexample\n):\n\n\n(ns app.blueprint-methods)\n\n(defn -tag-ns\n  \nReturns variant tag's namespace string. Examples:\n  [:a/foo :bar] -\n \\\na\\\n\n  [:a/foo] -\n \\\na\\\n\n  :a/foo -\n \\\na\\\n\n  :foo -\n nil\n\n  [variant]\n  (-\n (if (sequential? variant)\n        (first variant)\n        variant)\n      namespace))\n\n(defmulti on-signal (fn [_model signal _dispatch-signal _dispatch-action]\n                      (-tag-ns signal)))\n\n(defmulti on-action (fn [_model action]\n                      (-tag-ns action)))\n\n\n\n\n(ns app.common.signals\n  (:require [app.blueprint-methods :refer [on-signal]]\n            [cljs.core.match :refer-macros [match]]))\n\n; Standard signals have no namespace.\n(defmethod on-signal nil\n  [_model signal _dispatch-signal _dispatch-action]\n  (match signal\n         :on-start nil\n         :on-stop nil))\n\n(defmethod on-signal (namespace ::_) ; \n-- Note the trick for getting current ns name.\n  [_model signal _dispatch-signal dispatch-action]\n  (match signal\n         ::on-home (dispatch-action [:app.common.actions/navigate :home])\n         ::on-settings (dispatch-action [:app.common.actions/navigate :settings])))\n\n\n\n\n(ns app.common.actions\n  (:require [app.blueprint-methods :refer [on-action]]\n            [cljs.core.match :refer-macros [match]]))\n\n(defmethod on-action (namespace ::_)\n  [model action]\n  (match action\n         [::navigate pane] (assoc model :pane pane)))\n\n\n\n\nAll signals and actions must be namespaced now.\n\n\nMultimethods and Macros\n\n\n\nAs an alternative, instead of grouping we could use macros to simplify method definitions:\n\n\n(ns app.common.actions\n  (:require ,,,))\n\n; Macro which allows destructuring the event variant without repeating it in the arglist.\n; Inspired by http://jneen.net/posts/2014-11-23-clojure-conj-variants-errata\n(defcase on-action [:navigate pane]\n  [model]\n  (assoc model :pane pane))\n\n\n\n\n(ns app.common.signals\n  (:require ,,,))\n\n(defcase on-signal :on-start\n  [_model _dispatch-signal _dispatch-action]\n  nil)\n\n(defcase on-signal :on-stop\n  [_model _dispatch-signal _dispatch-action]\n  nil)\n\n(defcase on-signal :on-home\n  [_model _dispatch-signal dispatch-action]\n  (dispatch-action [:navigate :home]))\n\n(defcase on-signal :on-settings\n  [_model _dispatch-signal dispatch-action]\n  (dispatch-action [:navigate :settings]))\n\n\n\n\nConclusion\n\n\n\nWe've covered several ways of assembling handler functions from multiple files:\n\n\n\n\ndispatching-to-either\n helper (\nexample\n)\n\n\nmultimethods for individual events (\nexample\n)\n\n\nmultimethods for groups of events (\nexample\n)\n\n\nmacros on top of multimethods\n\n\n\n\nThe takeaway is that handlers are just functions and you can refactor them in any way you want.\n\n\nComposite Apps\n\n\nBecause Carry architecture is based on functions which can be nested inside each other,\nit is possible to build composite apps reusing existing apps. A composite app incorporates codebases of other Carry apps, but\nstill has a single model, signal handler and action handler.\n\n\nThough the idea is quite straightforward, it is a debatable design pattern because of the resulting code complexity,\nso use it with caution.\n\n\n\n\n\u26a0 \nUpdate (2016-10-13)\n: the pattern described in this chapter was heavily inspired by Elm Architecture\n(\nv0.16 tutorial\n).\nBut as of Elm v0.17 this \"parent/child communication\" approach is no longer encouraged in Elm community: \n\nflat is better than nested\n, so most of the time it's preferred to partition functions between files\ninstead of extracting \"encapsulated\" model/view/update triplets. \n\n\nRead more here:\n\n\n\n\nDiscussion: Design of Large Elm apps\n and\nespecially \nthis message\n\n\nDiscussion: Do the counters in the Guide teach us a wrong scaling approach?\n\n\nElm Guide: Scaling The Elm Architecture\n\n\n\n\nThis proves my initial sentiment about the complexity of the pattern.\nAnyway, for educational purposes the chapter is going to stay in this guide.\n\n\n\n\nLet's look at \ncounter-list\n example.\n\n\n\n\n For a simpler example of a \"statically assembled\" app please check \nsubapps\n project.\n\n\n\n\nIn this project \ncounter apps\n can be created and removed dynamically:\n\n\n\n  \n\n\n\n\ncarry-reagent\n package will be used for UI rendering.\n\n\ninitial-model\n\n\n\nThe model will store a list of counter app models:\n\n\n(ns app.model)\n\n(def initial-model\n  {; unsorted map: id -\n counter-model\n   :counters {}})\n\n\n\n\nview-model\n\n\n\nThe view model will contain \n:counters\n reaction with a sorted map of \n[id counter-view-model]\n pairs:\n\n\n(ns app.view-model\n  (:require [counter.core :as counter]\n            [reagent.core :as r]\n            [reagent.ratom :refer [reaction]]))\n\n;(defn view-model\n;  \nNaive nonoptimal implementation:\n;   counter view-models will be updated on every model update -\n\n;    every counter view will be reevaluated on each change.\n\n;  [model]\n;  (let [counter-view-model (fn [id]\n;                             (counter/view-model\n;                               (reaction (get-in @model [:counters id]))))]\n;    {:counters (reaction (into (sorted-map)\n;                               (for [[id _] (:counters @model)]\n;                                 [id (counter-view-model id)])))}))\n\n(defn view-model\n  \nOptimized implementation. Reuses counter view-models from the last reaction calculation.\n\n  [model]\n  (let [counter-view-models (atom (sorted-map))             ; id -\n counter-view-model\n        counter-view-model (fn [id]\n                             (or (get @counter-view-models id)\n                                 (counter/view-model\n                                   (reaction (get-in @model [:counters id])))))]\n    {:counters (reaction (reset! counter-view-models\n                                 (into (sorted-map)\n                                       (for [[id _] (:counters @model)]\n                                         [id (counter-view-model id)]))))}))\n\n\n\n\nThe optimized implementation calculates each counter view model only once.\nSo that all existing counter views are not unnecessarily evaluated by Reagent\non updating a single counter.\n\n\nNote how Reagent's \nreaction\n macro is used to create a counter model reaction for \ncounter/view-model\n:\n\n\n(reaction (get-in @model [:counters id]))\n\n\n\n\nview\n\n\n\n(ns app.util)\n\n(defn tagged\n  \nHelper function decorator which prepends a tag to the single argument.\n  I.e. it transforms an arg x to [tag x].\n\n  [f tag]\n  (fn tagged-fn\n    [x]\n    (f [tag x])))\n\n\n\n\n(ns app.view\n  (:require [app.util :refer [tagged]]\n            [counter.core :as counter]))\n\n(defn -counter\n  [[id view-model] dispatch]\n  [counter/view view-model (tagged dispatch [:on-counter-signal id])])\n\n(defn view\n  [view-model dispatch]\n  (let [counters (map #(-counter % dispatch) @(:counters view-model))\n        insert [:button {:on-click #(dispatch :on-insert)} \nInsert\n]\n        remove [:button {:on-click #(dispatch :on-remove)} \nRemove\n]]\n    (into [:div insert remove] counters)))\n\n\n\n\nAs you can see, \ncounter/view\n is created for each counter and will dispatch its signals \"tagged\"\nwith a corresponding counter id.\n\n\non-signal\n\n\n\nThe signal handler will let the individual counter handle the incoming signal.\nIn a more complex app we would also have to dispatch tagged \n:on-start\n/\n:on-stop\n signals\non inserting/removing subapps. But in this example we omit this because counter app has no start/stop code:\n\n\n(ns app.signals\n  (:require [app.util :refer [tagged]]\n            [counter.core :as counter]\n            [carry.core :as carry]\n            [cljs.core.match :refer-macros [match]]))\n\n(defn on-signal\n  [model signal dispatch-signal dispatch-action]\n  (match signal         \n         :on-insert (dispatch-action :insert)\n         :on-remove (dispatch-action :remove)\n\n         [[:on-counter-signal id] s]\n         ((:on-signal counter/blueprint)\n           (carry/entangle model #(get-in % [:counters id]))\n           s\n           (tagged dispatch-signal [:on-counter-signal id])\n           (tagged dispatch-action [:counter-action id]))))\n\n\n\n\nCarry's \nentangle\n helper is used to create a counter model for passing into counter signal handler.\nThis call returns a read-only reference object which will automatically sync its value with\n\n(get-in @model [:counters id])\n on \nmodel\n changes:\n\n\n(carry/entangle model #(get-in % [:counters id]))\n\n\n\n\non-action\n\n\n\nAction handler uses counter's initial model and action handler:\n\n\n(ns app.actions\n  (:require [counter.core :as counter]\n            [cljs.core.match :refer-macros [match]]))\n\n(defn on-action\n  [model action]\n  (match action\n         :insert\n         (let [newest-counter-id (apply max -1 (-\n model :counters keys))]\n           (assoc-in model [:counters (inc newest-counter-id)] (:initial-model counter/blueprint)))\n\n         :remove\n         (let [oldest-counter-id (apply min (-\n model :counters keys))]\n           (update model :counters dissoc oldest-counter-id))\n\n         [[:counter-action id] a]\n         (update-in model [:counters id] (:on-action counter/blueprint) a)))\n\n\n\n\nblueprint\n\n\n\nLet's define a blueprint in a separate namespace:\n\n\n(ns app.blueprint\n  (:require [app.model :refer [initial-model]]\n            [app.signals :refer [on-signal]]\n            [app.actions :refer [on-action]]))\n\n(def blueprint\n  {:initial-model initial-model\n   :on-signal     on-signal\n   :on-action     on-action})\n\n\n\n\nmain\n\n\n\nAnd finally, here's the app instantiation code:\n\n\n(ns app.core\n  (:require [app.blueprint :refer [blueprint]]\n            [app.view-model :refer [view-model]]\n            [app.view :refer [view]]\n\n            [carry.core :as carry]\n            [carry-reagent.core :as carry-reagent]\n\n            [reagent.core :as r]))\n\n(defn main\n  []\n  (let [app (carry/app blueprint)\n        [app-view-model app-view] (carry-reagent/connect app view-model view)]\n    (r/render app-view (.getElementById js/document \nroot\n))\n    (assoc app :view-model app-view-model)))\n\n(def app (main))", 
            "title": "User Guide"
        }, 
        {
            "location": "/user-guide/#basic", 
            "text": "Carry is actually a  very small \nClojure/ClojureScript state management library which provides a skeleton for the whole application.  The library is distributed via  Clojars  and has no dependencies.  All the additional features (debugging, UI binding, etc.) are not part of the core project\nand can be provided by third-party packages.  Some of them  are already implemented\nand hosted in Carry repo  contrib folder .\nMost of these packages are implemented using  Carry middleware pattern .  The private/internal API uses  -  prefix and should not be used (e.g.  -this-is-some-private-thing ).", 
            "title": "Basic"
        }, 
        {
            "location": "/user-guide/#app", 
            "text": "In a Carry application all the code you write is encapsulated behind a single  app  instance. \nAn app is a map with keys:   :model  - an in-memory representation of an app state  :dispatch-signal  - a function for interaction with an app   One can consider an app to be a black box which exposes its current state and modifies it on getting signals from an external world.\nIt can also affect an external world as a response to a signal, i.e. perform \"side effects\".", 
            "title": "App"
        }, 
        {
            "location": "/user-guide/#model", 
            "text": "Model represents an entire state of an app.   One can access app's model via  :model  key to obtain an object that can be dereferenced and watched.\nAn exception will be thrown on mutating such read-only reference:  (def my-model (:model my-app))\n\n; Dereference to get model value.\n@my-model\n;=  {...}\n\n; Start reacting to model changes.\n(add-watch my-model :my-watch\n           (fn [_key _ref old-state new-state]\n             (when (not= old-state new-state)\n               (println  model value has changed! ))))\n\n((:dispatch-signal my-app) some-model-changing-signal)\n;=  model value has changed!\n\n; Stop watching.\n(remove-watch my-model :my-watch)\n\n; It's impossible to directly mutate a model.\n(reset! my-model {:foo :bar})\n;=  Error: ...  Carry requires a model value to be a map. This convention allows writing reusable packages that can store additional data into any Carry app.\nAs an example,  carry-history  adds  :token  to a model.", 
            "title": "Model"
        }, 
        {
            "location": "/user-guide/#signals", 
            "text": "Signal  is an object which represents a user's intention or, looking at it from a different angle, a system event. \nSignal can be synchronously sent to an app by calling its  dispatch-signal  function:  ((:dispatch-signal my-app) my-signal)  dispatch-signal  always returns  nil .  Carry accepts signals of any type. But usually signal is a just keyword with \"on-\" prefix or\na serializable vector with a keyword and an additional payload:  :on-clear-completed\n[:on-update-todo id val]\n[:carry-history.core/on-enter token]  Using prefixes is recommended because it helps distinguish signal names from action names.", 
            "title": "Signals"
        }, 
        {
            "location": "/user-guide/#creating-an-app", 
            "text": "In order to create an instance of a Carry app a user has to pass a  blueprint  into  app  function:  (let [my-app (carry/app my-blueprint)]\n  ; ...\n  )  A blueprint is a map with keys:   :initial-model  - an initial model value  :on-signal  - a function for handling signals  :on-action  - a function for handling actions   In other words, a blueprint is needed to define a runtime behavior of an app:", 
            "title": "Creating an App"
        }, 
        {
            "location": "/user-guide/#signal-handler", 
            "text": "Signal handler  is a part of an application responsible for processing incoming signals. \nIt can dispatch new signals, modify app model (by dispatching actions) and perform any side effects (e.g. send data to a server).\nIt is free to contain an asynchronous code. The signature of a signal handler function:  (defn on-signal\n  [model signal dispatch-signal dispatch-action])   model  - a read-only reference, the same as app's  :model  signal  - an incoming signal   dispatch-signal  - a synchronous function for dispatching new signals, the same as app's  :dispatch-signal , can return some value  dispatch-action  - a synchronous function for modifying a model, always returns  nil   By convention, signal handler should be able to at least handle  :on-start  and  :on-stop  signals.\nAs we'll see later, it's required by middleware with setup/teardown logic and to support hot reloading.  It is convenient (but not required) to use  pattern matching  \nto switch between signals and destructure signals with payload.\nAs an example, this is a handler from  friend-list  demo app:  (ns friend-list.core\n  (:require [carry-history.core :as h]\n            ; ...\n            [goog.functions :refer [debounce]]\n            [cljs.core.match :refer-macros [match]]))\n\n; It's recommended to create a factory function if signal handler uses external dependencies.\n; It makes code more decoupled and \n; easier to unit test (stubs/mocks can be easily used instead of real implementations).\n; In this example browser history manager and API client are external dependencies.\n(defn -new-on-signal\n  [history api-search]\n  ; Some helper functions.\n  ; On successful search a new :on-search-success signal will be dispatched.\n  (let [search (fn [q dispatch-signal] (api-search q #(dispatch-signal [:on-search-success q %])))\n        search-on-input (debounce (fn [q dispatch-signal]\n                                    (h/push-token history q)\n                                    (search q dispatch-signal))\n                                  300)]\n    ; Function name is specified for better stacktraces.\n    (fn on-signal\n      [model signal dispatch-signal dispatch-action]\n      (match signal\n             ; This application has no custom setup/teardown logic\n             ; so just return nil on standard signals:             \n             :on-start nil\n             :on-stop nil\n\n             ; Signal destructuring example \n             [:on-input q]\n             (do\n               ; Update model.\n               (dispatch-action [:set-query q])\n\n               ; Begin (possibly async) searching.\n               (search-on-input q dispatch-signal))\n\n             ; ...\n\n             [:on-search-success q friends]\n             ; Note that model has to be dereferenced to get its value.\n             (if (= (:query @model) q)\n               (dispatch-action [:set-friends friends])\n               (println  ignore response for  (pr-str q)\n                         because current query is  (pr-str (:query @model))))))))\n\n; ...\n\n; Dependencies will be injected in a blueprint factory function:\n(defn new-blueprint\n  [history api-search]\n  {; ...\n   :on-signal (-new-on-signal history api-search)})\n\n; ...\n\n; Create and start an app using concrete dependencies.\n(def my-app (carry/app (new-blueprint my-history my-api-client)))\n((:dispatch-signal app) :on-start)  You're free to return any value from a signal handler. \nE.g. an asynchronous signal can return a  core.async  channel or a promise\nso that other code can wait for it.", 
            "title": "Signal Handler"
        }, 
        {
            "location": "/user-guide/#actions", 
            "text": "Action  is an object which represents an intention to modify a model.\nActions can be dispatched only from within a signal handler via  dispatch-action .  Similar to signals, actions are usually keywords or vectors, for instance:  :increment\n[:set-query q]", 
            "title": "Actions"
        }, 
        {
            "location": "/user-guide/#action-handler", 
            "text": "Action handler  is a part of an application responsible for processing incoming actions.\nIt's a pure function which returns a new model value based on a current model value and an incoming action.\nOn getting an action an app passes it into a action handler and then resets app model value with the result.  A simple example from  friend-list  demo app:  (defn -on-action\n  [model action]\n  (match action\n         [:set-query q]\n         (assoc model :query q)\n\n         [:set-friends friends]\n         (assoc model :friends friends)))  It's important to not put any asynchronous code, side effects or nondeterministic code (e.g. random number generation)\ninto action handler. Otherwise, it will make replaying actions unpredictable and break time traveling debugging.", 
            "title": "Action Handler"
        }, 
        {
            "location": "/user-guide/#usage-with-reagent", 
            "text": "Carry can work with any view layer that is able to re-render UI in response to app model changes.\nThis chapter is about tying Carry with  Reagent  \n(a ClojureScript wrapper for  React )\nusing  carry-reagent  package:   (ns app.core\n  (:require [carry.core :as carry]\n            [carry-reagent.core :as carry-reagent]\n            [reagent.core :as r]))\n\n; ...\n\n; Define app view model and view:\n\n(defn my-view-model\n  [model]\n  ; define a view model...\n)\n\n(defn my-view\n  [view-model dispatch]\n  ; a Reagent component that uses data from a view-model and dispatches signals on events...\n)\n\n(let [; Create an app.\n      app (carry/app my-blueprint)\n\n      ;  Connect  app, view model and view to create a Reagent component.\n      [_ app-view] (carry-reagent/connect app my-view-model my-view)]\n    ; Render component into DOM.\n    (r/render app-view (.getElementById js/document  root ))\n\n    ; ...\n)  App view is constructed using  carry-reagent.core/connect  function:  (connect [app view-model view])   app  - Carry app instance  view-model  - a function which produces a view model  view  - a Reagent component  returns a pair  [view-model-instance view-component]  (view model is returned mainly for debugging)   view-model  function is called once on  connect  call.\nThen returned view model instance is passed as an argument into  view  function to produce a final view component.\nA view thereby listens to a view model that in turn listens to a model:   In the next section we'll see how to define a view model.", 
            "title": "Usage with Reagent"
        }, 
        {
            "location": "/user-guide/#view-model", 
            "text": "View model  contains all the data needed to render a UI.\nIt can compute derived model data, split lists of objects into pages, calculate which buttons are enabled, \ndetermine which app page to show depending on current URL, etc.  Usually view model is a map of Reagent reactions. An example from  TodoMVC  app:  (ns app.view-model\n  (:require ; ...\n            [carry-reagent.core :as carry-reagent]\n            [reagent.ratom :refer [reaction]]))\n\n(defn view-model\n  [model]\n  (let [; ...\n        ; Wrap todo items in a reaction.\n        all-todos (reaction (:todos @model))]\n    (-  model\n        ; This helper function call will return {:field (reaction (:field @model))} map\n        ; (:field contains the value of a new todo input field).\n        (carry-reagent/track-keys [:field])\n\n        ; Additional view model fields are reactions \n        ; which will be recalculated if (and only if) all-todos value changes:\n        (assoc :has-todos? (reaction (-  @all-todos count pos?))\n               :all-completed? (reaction (every? :completed? @all-todos))\n               ; ...\n               ))))  Argument  model  is a  Reagent reaction  that tracks app model changes.\nReaction is a special reference-like object that is created using Reagent's  reaction  macro.\nIt is lazily computed from other reactions and Reagent atoms\n(see  official documentation  for more information about Reagent atoms).\nAny Reagent component that dereferences a reaction is going to be automatically re-rendered when reaction value updates.", 
            "title": "View Model"
        }, 
        {
            "location": "/user-guide/#view", 
            "text": "An example from  TodoMVC  app:  ; A plain Reagent component which is redrawn when input arguments change.\n(defn -header\n  [field dispatch]\n  ; Reagent uses Hiccup-like syntax for defining HTML.\n  [:header.header\n   [:h1  todos ]\n\n   ; Input value is equal to field arg value.\n   [:input.new-todo {:placeholder  What needs to be done? \n                     :value       field\n\n                     ; Dispatch signals on input events.\n                     :on-change   #(dispatch [:on-update-field (.. % -target -value)])\n                     :on-key-down #(when (-enter-key? %) (dispatch :on-add))}]])\n\n; Top app component that is passed into connect function.\n(defn view\n  ; Destructure view model map for cleaner code in the function body.\n  [{:keys [field has-todos? all-completed?\n           ; ...\n           ] :as _view-model}\n   dispatch]\n  [:section.todoapp\n   ; Deref |field| reaction to get its value for rendering.\n   ; Derefing also makes parent component start watching for |field| changes \n   ; so that -header will be re-rendered on |field| updates. \n   [-header @field dispatch]\n\n   ; ...\n   ]))  As you can see, we get reactions from a view model and deref them to render actual values.\nReagent will then \"magically\" re-render components when the reactions passed into them are updated.", 
            "title": "View"
        }, 
        {
            "location": "/user-guide/#usage-with-figwheel-and-repl", 
            "text": "With  Figwheel  Leiningen plugin it is possible to:   compile and reload app code in browser on source code changes  communicate with a running app via REPL   Most of Carry  examples  use Figwheel for development builds and \nrely on the \"bare\"  lein-cljsbuild  for production builds.  The main thing to remember is to stop the currently running app before hot reload \nin order to unsubscribe it from browser events and free memory.\nHere's how you can structure your main app file to be used with Figwheel:   (ns app.core\n  (:require [carry.core :as carry]\n            [carry-reagent.core :as carry-reagent]\n            [reagent.core :as r]))\n\n; ...\n\n(defn main\n  []\n  (let [app (carry/app my-blueprint)\n        [app-view-model app-view] (carry-reagent/connect app my-view-model my-view)]\n    (r/render app-view (.getElementById js/document  root ))\n\n    ; Start the app.\n    ((:dispatch-signal app) :on-start)\n\n    ; For debugging purposes add view-model into returned map.\n    (assoc app :view-model app-view-model)))\n\n; Start new app and save it into the global var for debugging in REPL.\n(def app (main))\n\n;;;;;;;;;;;;;;;;;;;;;;;; Figwheel stuff\n; These functions should be specified in project.clj :figwheel map.\n\n; Stop current app before loading a new one.\n(defn before-jsload\n  []\n  ((:dispatch-signal app) :on-stop))\n\n(defn on-jsload\n  []\n  #_(. js/console clear))  To get an interactive development environment run:  lein figwheel  or better:  rlwrap lein figwheel  and open your browser at  localhost:3449 .\nThis will auto compile and send all changes to the browser without the\nneed to reload. After the compilation process is complete, you will\nget a Browser Connected REPL. An easy way to try it is:  (js/alert  Am I connected? )  and you should see an alert in the browser window.  You can also directly access  app  map from REPL:  cljs.user=  (ns app.core)\nnil\n\napp.core=  (keys app)\n(:model :dispatch-signal :view-model)\n\napp.core=  @(:model app)\n{...}\n\napp.core=  ((:dispatch-signal app) :on-increment)\nnil  You may also want to directly modify the app model in REPL without dispatching signals/actions.\nThis can be achieved by using  carry-atom-sync  middleware\nto create a helper \"model atom\" specifically for debugging in REPL. An example from  TodoMVC :  (ns app.core\n  (:require [app.blueprint :as blueprint]\n            [carry-atom-sync.core :as atom-sync]\n            ; ...\n            )) \n; ...\n\n;  Model atom  exposed for debugging in REPL.\n(def model (atom nil))\n\n(defn main\n  []\n  (let [blueprint (-  (blueprint/new-blueprint ...)\n                       ; ...\n                       ; Apply middleware to setup a sync with  model atom .\n                       (atom-sync/add model))\n        app (carry/app blueprint)\n        ; ...\n        ]\n    ; ...\n    ((:dispatch-signal app) :on-start)\n    ; ...\n    ))\n\n; ...  Now after app is started you can directly work with app model via  model  atom in REPL:  app.core=  (cljs.pprint/pprint (dissoc @model :carry-debugger.core/debugger))\n{:field  ,\n :todos\n ({:id 0,\n   :title  Finish this project ,\n   :completed? false,\n   :original-title  ,\n   :editing? false}\n  {:id 1,\n   :title  Take a bath ,\n   :completed? true,\n   :original-title  ,\n   :editing? false}), \n :next-id 2, \n :carry-history.core/token  }\n\napp.core=  (swap! model assoc :field  foobar )\n{:field  foobar , ...}\n\napp.core=  (= @model @(:model app))\ntrue", 
            "title": "Usage with Figwheel and REPL"
        }, 
        {
            "location": "/user-guide/#advanced", 
            "text": "", 
            "title": "Advanced"
        }, 
        {
            "location": "/user-guide/#middleware", 
            "text": "Middleware  is a function that gets an app blueprint and returns an updated blueprint\nin order to introduce some new app behavior (such as logging, syncing with server, crash reporting).    Also see:  ready-to-use middleware packages .   Multiple middleware can be applied in a chain to produce a new blueprint.\nFor instance,  TodoMVC  app blueprint is wrapped by three middleware:  (defn new-blueprint\n  [history storage storage-key todo-titles]\n  (-  {:initial-model (model/new-model todo-titles)\n       :on-signal     on-signal\n       :on-action     on-action}\n\n      ; 1\n      (schema/add model/Schema)\n\n      ; 2\n      (persistence/add storage storage-key {:blacklist #{::h/token}})\n\n      ; 3\n      (h/add history)))  An order in which middleware are applied matters. One can think of it as an onion: each middleware is a layer that wraps a blueprint\nand handles bypassing signals and actions:   As an example, this is a simple middleware which logs all actions and signals coming through an app:  (ns carry-logging.core\n  (:require))\n\n(defn add\n   Will print all signals and actions to console using the specified prefix string. \n  ([blueprint] (add blueprint  ))\n  ([blueprint prefix]\n   (-  blueprint\n       ; Wrap signal handler to log signals.\n       (update :on-signal\n               (fn wrap-on-signal [app-on-signal]\n                 (fn on-signal [model signal dispatch-signal dispatch-action]\n                   (try\n                     ; Log.\n                     (.group js/console (str prefix  signal   (pr-str signal)))\n\n                     ; Let app handle the signal.\n                     (app-on-signal model signal dispatch-signal dispatch-action)\n\n                     ; this clause guarantees that group is closed even in case of exception\n                     (finally\n                       (.groupEnd js/console))))))\n\n       ; Wrap action handler to log actions.\n       (update :on-action\n               (fn wrap-on-action [app-on-action]\n                 (fn on-action [model action]\n                   ; Log.\n                   (.log js/console (str prefix  action ) (pr-str action))\n\n                   ; Let app handle the action.\n                   (app-on-action model action)))))))  More complex middleware can:   Modify initial model.  Intercept  :on-start / :on-stop  signals.  Dispatch new signals and actions to an app.\nBy convention, they must use namespaced keywords (e.g.  :my-middlware.core/on-something ) to prevent a name clash with other signals.  Dispatch \"own\" signals and actions (also namespaced) which should not be handled by a wrapped app.  Subscribe to model changes.  Have injected dependencies.   All these cases are demonstrated by  carry-history  middleware:  (ns carry-history.core\n  ; ...\n)\n\n(defn -wrap-initial-model\n  [app-initial-model]\n  (merge {::token  / } app-initial-model))\n\n; History will be injected on applying the middleware.\n(defn -wrap-on-signal\n  [app-on-signal history]\n  (let [unlisten (atom nil)]\n    (fn on-signal\n      [model signal dispatch-signal dispatch-action]\n      (match signal\n             ; Intercept :on-start signal.\n             :on-start\n             ; Let the wrapped app start first.\n             (let [original-signal-result (app-on-signal model signal dispatch-signal dispatch-action)]\n               ; Start listening to model updates.\n               (add-watch model ::token-watch\n                          (fn [_key _ref old-state new-state]\n                            ; ...\n                            ))\n\n               ; Start listening to history events.\n               (reset! unlisten\n                       (listen history #(dispatch-signal [::on-history-event ; ...\n                                                          ])))\n\n               ; ...      \n\n               ; Preserve the return value of the wrapped signal.\n               original-signal-result)\n\n      ; Intercept clean up signal.\n      :on-stop\n      (do\n        ; Unsubscribe from history events. \n        ; Otherwise, on hot reload unused listeners will stay in memory.\n        (@unlisten)\n\n        ; There's no need to remove model watches on hot reload \n        ; because they will be garbage-collected with the model.\n\n        ; Let the wrapped app continue cleaning up.\n        (app-on-signal model signal dispatch-signal dispatch-action))\n\n      ; Middleware-specific signal that will not be passed further to an app.\n      [::on-history-event {:token token :browser-event? browser-event? :event-data event-data}]\n      (do\n        ; Dispatch a middleware-specific action.\n        (dispatch-action [::set-token token])\n\n        (when (or browser-event? (:treat-as-browser-event? event-data))\n          ; Dispatch a signal to an app.\n          (dispatch-signal [::on-enter token])))\n\n      ; Pass other signals further.\n      :else\n      (app-on-signal model signal dispatch-signal dispatch-action)))))\n\n(defn -wrap-on-action\n  [app-on-action]\n  (fn on-action\n    [model action]\n    (match action\n           ; A middleware-specific action.\n           [::set-token token]\n           (assoc model ::token token)\n\n           ; Pass other actions further.\n           :else\n           (app-on-action model action))))\n\n; History is an injected dependency.\n(defn add\n  [blueprint history]\n  (-  blueprint\n      (update :initial-model -wrap-initial-model)\n      (update :on-signal -wrap-on-signal history)\n      (update :on-action -wrap-on-action)))  Especially note how  :on-start / :on-stop  signals are intercepted:   The middleware let's the wrapped app start first and then runs its own additional initialization code.\nIt doesn't modify the return value of the underlying signal handler.  The order is \"reversed\" on stopping: the middleware first cleans up after itself and only then let's the wrapped app shutdown.", 
            "title": "Middleware"
        }, 
        {
            "location": "/user-guide/#debugger", 
            "text": "One of the main features of Carry pattern is that it allows time traveling debugging\nsimilar to  Elm's Debugger , Redux DevTools  and  Cerebral Debugger .  Carry has its own visual time traveling debugger with next features:   Debugger records all app signals and actions and shows them as a tree.  A signal is displayed as a respective tree leaf if it's dispatched from inside another signal.  Debugger records results of every action so that every past model value can be logged to console.  Any action can be disabled/enabled. On toggling an action debugger will reset app model \nto its initial value and  replay  all enabled actions.\nThis way user can immediately see how the app would look like if the action never took place.\nAction replaying is possible because actions are always pure and change app model in a predictable way.\nOn the other hand, it's impossible to predictably replay signals as they can perform async side effects.  Clicking a signal toggles all its child actions.  Clicking \"Replay\" button enables debugger's \"replay mode\" and marks already recorded actions as \"to be replayed\".\nThese actions are saved into local storage and will be automatically replayed on next app start.\nIn combination with Figwheel hot reloading this allows editing action handling code\nand immediately see how it affects a final app state (effectively \"changing the past\").  Debugging session can be saved into a file and then loaded.  \"Clear\" button removes all recorded signals and actions without modifying current app state.  \"Vacuum\" removes all disabled actions and \"dangling\" signals without enabled actions.  \"Reset\" resets an app to its initial state and clears recorded signals and actions.  Currently debugger uses Reagent+jQuery UI to render a resizable overlay view.   \n     To use a debugger developer has to apply  carry-debugger  middleware,\nconnect a debugger view and render it alongside an app view:  (ns app.core\n  (:require [carry.core :as carry]\n            [carry-reagent.core :as carry-reagent]\n            [carry-debugger.core :as debugger]\n            [reagent.core :as r]\n            [hodgepodge.core :as hp]\n            ; ...\n            ))\n\n; ...\n\n(defn main\n  []\n  (let [; Use hodgepodge lib for dealing with browser's local storage.\n        storage hp/local-storage\n\n        ; Apply middleware.\n        app-blueprint (-  my-blueprint\n                          ; Middleware requires a storage and a unique storage key.\n                          (debugger/add storage :my-debugger-model))\n\n        ; App and UI.\n        app (carry/app app-blueprint)\n        [_ app-view] (carry-reagent/connect app my-view-model my-view)\n\n        ; Connect debugger UI.\n        [_ debugger-view] (debugger/connect app)]\n    ; Render app and debugger views.\n    (r/render [:div app-view debugger-view] (.getElementById js/document  root ))\n\n    ; Start.\n    ((:dispatch-signal app) :on-start)\n\n    ; ...\n    ))  For correct rendering debugger also requires jQuery UI CSS to be injected into HTML.\nPlease see  API reference  for more info.  There are cases when you'd like to check if debugger is in replay mode.\nFor instance,  carry-history \nmiddleware doesn't send its initial  :on-enter  signal in replay mode.\nSuch behavior makes live coding more pleasant as developer expects only marked actions to be replayed on app start.\nDebugger mode can be determined by looking at  [:carry-debugger.core/debugger :replay-mode?]  path in a model map:  (ns carry-history.core\n  ; ...\n  )\n\n; ...\n\n(defn -wrap-on-signal\n  [app-on-signal history]\n  (let [unlisten (atom nil)]\n    (fn on-signal\n      [model signal dispatch-signal dispatch-action]\n      (match signal\n             :on-start\n             (do\n               (app-on-signal model signal dispatch-signal dispatch-action)\n\n               ; ...\n\n               ; Check if we're in replay mode before sending an initial signal\n               (when (not (-  @model :carry-debugger.core/debugger :replay-mode?))\n                 (dispatch-signal [; ... \n                                   ])))\n             ; ...\n             ))))\n; ...", 
            "title": "Debugger"
        }, 
        {
            "location": "/user-guide/#unit-testing", 
            "text": "It is comparatively easy to unit test a Carry app\nwith Reagent bindings because its behavior is implemented in four functions with explicit dependencies: on-signal ,  on-action ,  view-model ,  view .  Let's look at how these functions are tested in friend-list  example:", 
            "title": "Unit Testing"
        }, 
        {
            "location": "/user-guide/#routing", 
            "text": "It's not uncommon for applications to depend on a current URL and modify it in response to user actions.\nFor these tasks  carry-history  middleware\nprovides a bidirectional synchronization between a browser URL and a model:   An app can react to URL changes by observing model's  :token  (token, roughly, is everything that goes after a hostname).  If token in model is changed by an app then a browser will accordingly update its address bar.\nThis is especially useful during time traveling debugging as toggling token-changing actions will correctly update a URL.     Examples:   Friend List  - in this application a token is synced with a search query.  TodoMVC  - here  Silk  routing library is added to parse and build tokens.    Use  add  to apply the middleware\nand don't forget to start the app:  (ns app.core\n  (:require [carry.core :as carry] \n            [carry-history.core :as h]\n            ; ...\n            ))\n\n; ...\n\n(let [history (h/new-hash-history)\n      app-blueprint (-  my-blueprint\n                        (h/add history))\n      app (carry/app app-blueprint)\n      ; ...\n      ]\n    ((:dispatch-signal app) :on-start)\n    ; ...  The middleware requires a  History API  \nwrapper to be provided.\nSuch object must satisfy  HistoryProtocol \nand there are several constructors for creating such instances:    (new-legacy-hash-history)    (new-hash-history)    (new-history)      carry-history uses  Google Closure \nlibrary for interfacing with History API.   A wrapped app can now react to token changes:  (defn view-model\n  [model]\n  {:token (reaction (::h/token @model))})\n\n(defn view\n  [{:keys [token] :as _view-model} dispatch]\n  [:p  Current token =   (pr-str @token)])  It also becomes possible to react to token changes by handling  ::on-enter  signal.\nIt will be dispatched on app start and on changes initiated by user actions (e.g. editing an address or clicking Back button):  (match signal\n       [::h/on-enter token]\n       (println  navigated to page at   (pr-str token))\n\n       ; ...  Package's  link  Reagent component can be used to create in-app links which don't hit the server.\nAn example from  TodoMVC :  (defn -footer-filters\n  [visibility-config history]\n  [:ul.filters\n   (for [{:keys [title route selected?]} visibility-config]\n     ^{:key route}\n     [:li [h/link history (router/route- token route)\n           {:class (if selected?  selected )}\n           title]])])  Please see  API reference  for more info.", 
            "title": "Routing"
        }, 
        {
            "location": "/user-guide/#usage-with-datascript", 
            "text": "See examples:   Counter DataScript  Shopping Cart", 
            "title": "Usage with DataScript"
        }, 
        {
            "location": "/user-guide/#usage-with-devcards", 
            "text": "This section describes how to make Carry work with  Devcards  for a \"visual REPL experience\".\nFurther I assume you have a basic understanding of Devcards and I won't focus on why it's needed, installation details, etc.\nWe'll see how to render Carry/Reagent app instances inside cards.    This chapter is based on  counter-devcards  example project.   This is a simplest card for the app which uses  carry-reagent  for UI:  \n     (ns app.core\n  (:require [counter.core :as counter]\n            [carry.core :as carry]\n            [carry-reagent.core :as carry-reagent]\n            [reagent.core :as r]\n            [devcards.core :refer-macros [defcard-rg]]))\n\n; ...\n\n(defcard-rg\n  counter\n  (let [app (carry/app counter/blueprint)\n        [_ app-view] (carry-reagent/connect app counter/view-model counter/view)]\n    app-view))  Here  defcard-rg  macro is used to render an app Reagent component.\nOn hot reload (e.g. via Figwheel) a new app will be created from scratch.  This example lacks dispatching standard  :on-start / :on-stop  signals, let's fix this:  (defn -with-mount-callbacks\n  [_component on-did-mount on-will-unmount]\n  (r/create-class {:reagent-render         (fn [component _on-did-mount _on-will-unmount] component)\n                   :component-did-mount    (fn [_this] (on-did-mount))\n                   :component-will-unmount (fn [_this] (on-will-unmount))}))\n\n(defcard-rg\n  counter\n  (let [app (carry/app (-  counter/blueprint\n                           (logging/add  [counter]  )))\n        [_ app-view] (carry-reagent/connect app counter/view-model counter/view)]\n\n    [-with-mount-callbacks\n     app-view\n     #((:dispatch-signal app) :on-start)\n     #((:dispatch-signal app) :on-stop)]))  A helper Reagent component  -with-mount-callbacks  is created for starting the app after mounting and for stopping the app\nwhen the card component is going to unmount on hot reload.   Devcards also has an ability to display a simple time traveling \"history\" widget to go back and forward between recorded\ncomponent state values ( demo ):  \n     (defcard bmi-calculator                        ;; optional symbol name\n   *Code taken from Reagent readme.*           ;; optional markdown doc\n  (fn [data-atom _] (bmi-component data-atom)) ;; object of focus\n  {:height 180 :weight 80}                     ;; optional initial data\n  {:inspect-data true :history true})          ;; optional devcard config options  It doesn't work out out-of-box with Carry because a Carry app has no ability to expose its underlying model atom to a card.\nTo solve this we use  carry-atom-sync  middleware\nwhich creates a bidirectionally sync between the \"data atom\" created by Devcards and an app model:  \n     (ns app.core\n  (:require [counter.core :as counter]\n            [carry.core :as carry]\n            [carry-atom-sync.core :as carry-atom-sync]\n            [carry-reagent.core :as carry-reagent]\n            [cljs.core.match :refer-macros [match]]\n            [devcards.core :refer-macros [defcard-rg]]))\n\n; ...\n\n(defcard-rg\n  counter-with-history\n   Preserves model value between hot reloads. \n  (fn [data-atom _]\n    ; Create app instance.\n    (let [app (carry/app (-  counter/blueprint\n\n                             ; Get model value from data atom.\n                             (assoc :initial-model @data-atom)\n\n                             ; Setup bidirectional sync with data atom.\n                             (carry-atom-sync/add data-atom)\n\n                             (logging/add  [counter-with-history]  )))\n          [_ app-view] (carry-reagent/connect app counter/view-model counter/view)]\n      ; Render app view.\n      [-with-mount-callbacks\n       app-view\n\n       ; Start the app after mounting.\n       #((:dispatch-signal app) :on-start)\n\n       ; Stop the app on umount/hot-reload.\n       #((:dispatch-signal app) :on-stop)]))\n\n  ; Create data atom with initial model value.\n  (atom (:initial-model counter/blueprint))\n\n  ; Card options.\n  {:inspect-data true\n   :history      true})  What's happening here:   A new app instance is created on each hot reload.  The data atom is created once and then conveniently preserves its value between hot reloads.  On creation an app takes its initial value from the data atom.  On UI interactions all app model updates are propagated into the data atom enlarging the card's history stack.  On clicking history widget buttons the data atom is updated and its new values are synced back into the app model.    Of course, if a lot of cards are created like this then extracting a \nhelper macro or function should be considered in order to reduce code duplication.  Note that we must start the app only after mounting.\nOtherwise, starting app synchronously in a card function will produce\na  \"setState(...): Cannot update during an existing state transition\"  warning on hot reloads\n(because  carry-atom-sync  middleware resets  data-atom ):  (defcard-rg\n  counter-with-history\n  (fn [data-atom _]\n   ; ...\n\n   ; Will produce a warning:\n   ((:dispatch-signal app) :on-start)   \n\n   [-with-mount-callbacks\n    app-view\n    ; ...\n    ])\n\n   ; ...\n  )", 
            "title": "Usage with Devcards"
        }, 
        {
            "location": "/user-guide/#file-structure", 
            "text": "As an application grows it starts making sense to organize its code using folders and files.\nLet's look at some examples of organizing a source folder.", 
            "title": "File Structure"
        }, 
        {
            "location": "/user-guide/#blueprint-splitting", 
            "text": "Let's take the project structure example mentioned earlier:  app/\n  foo/\n    model.cljs\n    signals.cljs\n    actions.cljs\n    view_model.cljs\n    view.cljs\n  bar/\n    model.cljs\n    signals.cljs\n    actions.cljs\n    view_model.cljs\n    view.cljs\n  core.cljs  How to define a single Carry blueprint from the code scattered over all these files?\nIt is simple to merge all initial models to get a full model,\nbut there can be different ways to assemble handler functions:  (def blueprint {:initial-model (merge app.foo.model/initial-model\n                                      app.bar.model/initial-model)\n                :signal-halder ??? \n                :action-handler ???}  There are two conceptual ways of splitting a handler:   At a level of \"cases\" (signals/actions):   app/\n  foo/\n    signals.cljs  -- handles signals :on-a, :on-b\n  bar/\n    signals.cljs  -- handles signals :on-c, :on-d   Code for each individual signal/action can also be split between files:   app/\n  foo/\n    signals.cljs  -- handles :on-a and partially :on-b\n  bar/\n    signals.cljs  -- handles :on-c, :on-d and partially :on-b  Which approach is better? There's no definite answer. For instance, take a look at the discussions about the similar problem in Flux/Redux:   Problems with Flux  Redux issue #1400   We'll see how to implement the first, stricter and simpler, approach and \nleave implementing the second approach as an exercise to the reader.", 
            "title": "Blueprint Splitting"
        }, 
        {
            "location": "/user-guide/#composite-apps", 
            "text": "Because Carry architecture is based on functions which can be nested inside each other,\nit is possible to build composite apps reusing existing apps. A composite app incorporates codebases of other Carry apps, but\nstill has a single model, signal handler and action handler.  Though the idea is quite straightforward, it is a debatable design pattern because of the resulting code complexity,\nso use it with caution.   \u26a0  Update (2016-10-13) : the pattern described in this chapter was heavily inspired by Elm Architecture\n( v0.16 tutorial ).\nBut as of Elm v0.17 this \"parent/child communication\" approach is no longer encouraged in Elm community:  flat is better than nested , so most of the time it's preferred to partition functions between files\ninstead of extracting \"encapsulated\" model/view/update triplets.   Read more here:   Discussion: Design of Large Elm apps  and\nespecially  this message  Discussion: Do the counters in the Guide teach us a wrong scaling approach?  Elm Guide: Scaling The Elm Architecture   This proves my initial sentiment about the complexity of the pattern.\nAnyway, for educational purposes the chapter is going to stay in this guide.   Let's look at  counter-list  example.    For a simpler example of a \"statically assembled\" app please check  subapps  project.   In this project  counter apps  can be created and removed dynamically:  \n     carry-reagent  package will be used for UI rendering.", 
            "title": "Composite Apps"
        }, 
        {
            "location": "/examples/", 
            "text": "Most apps support hot reloading and REPL debugging via \nFigwheel\n.\n\n\nCounter Vanilla\n\n\nSource code\n\n\nDemo\n\n\nThe most trivial example. Uses \"vanilla\" JavaScript to render a UI.\n\n\nCounter\n\n\nSource code\n\n\nDemo\n\n\nThe basic example of using Carry with \ncarry-reagent\n\nfor rendering UI using \nReagent\n.\n\n\nFriend List\n\n\nSource code\n\n\nDemo\n\n\nInspired by this \nproblem\n about dynamic search input.\nDemonstrates how to dispatch new signals from signal handler and also features:\n\n\n\n\ncarry-reagent\n\nfor rendering UI using \nReagent\n\n\ncarry-history\n for routing\n\n\ncarry-schema\n for model validation using \nSchema\n\n\ncarry-debugger\n for time traveling debugging\n\n\ncarry-logging\n for logging to console\n\n\nunit tests\n\n\n\n\nTodoMVC\n\n\nSource code\n\n\nDemo\n\n\nThe implementation of \nTodoMVC\n reference example.\n\n\nFeatures:\n\n\n\n\ncarry-reagent\n\nfor rendering UI using \nReagent\n\n\ncarry-history\n and \nSilk\n for routing\n\n\ncarry-persistence\n and \nhodgepodge\n for local storage persistence\n\n\ncarry-schema\n for model validation using \nSchema\n\n\ncarry-debugger\n for time traveling debugging\n\n\ncarry-logging\n for logging to console\n\n\nuses \nSpecter\n for model updates\n\n\ncarry-atom-sync\n to directly access app model as an atom in REPL\n\n\n\n\nPickings\n\n\nSource code\n\n\nThe small desktop app using Carry.\n\n\nFeatures:\n\n\n\n\nwritten in Clojure\n\n\nSeesaw\n for UI\n\n\nreloaded workflow\n for easier running from REPL\n\n\n\n\nApps Using DataScript\n\n\nCounter DataScript\n\n\nSource code\n\n\nDemo\n\n\nThe simplest example of using \nDataScript\n in-memory database for a model and \n\ncarry-reagent\n\nfor rendering UI using \nReagent\n.\n\n\nShopping Cart\n\n\nSource code\n\n\nDemo\n\n\nThe more advanced example of using \nDataScript\n \nand \ncarry-reagent\n.\nInspired by \nflux-comparison\n problem.\n\n\nCounter Devcards\n\n\nSource code\n\n\nDemo\n\n\nAn example of rendering \ncounter app\n in \nDevcards\n.\nAlso see \nguide\n.\n\n\nFeatures:\n\n\n\n\ncarry-atom-sync\n for making Devcards history work seamlessly with Carry\n\n\ncarry-reagent\n\nfor rendering UI using \nReagent\n \n\n\ncarry-logging\n for logging to console\n\n\n\n\nBlueprint Splitting\n\n\nSee \nguide\n.\n\n\nHOF\n\n\nSource code\n\n\nDemo\n\n\nDemonstrates how to assemble a blueprint and UI from multiple modules using higher-order functions. \n\n\nFeatures:\n\n\n\n\ncarry-reagent\n\nfor rendering UI using \nReagent\n\n\n\n\nMultimethods\n\n\nSource code\n\n\nDemo\n\n\nDemonstrates how to assemble a blueprint from multiple modules with a help of multimethods. \n\n\nFeatures:\n\n\n\n\ncarry-reagent\n\nfor rendering UI using \nReagent\n\n\n\n\nMultimethods \n core.match\n\n\nSource code\n\n\nDemo\n\n\nDemonstrates how to assemble a blueprint from multiple modules with a help of multimethods and \ncore.match\n. \n\n\nFeatures:\n\n\n\n\ncarry-reagent\n\nfor rendering UI using \nReagent\n\n\n\n\nComposite Apps\n\n\nSee \nguide\n.\n\n\nSubapps\n\n\nSource code\n\n\nDemo\n\n\nIn this project \ncounter app\n and \nfriend list app\n instances are \"statically\" added to the app blueprint.\nSeveral helper methods are extracted to make it easy to include any subapp at the time of app instantiation.\n\n\nCounter List\n\n\nSource code\n\n\nDemo\n\n\nIn this example \ncounter app\n instances are created and removed dynamically after app is started.\nInspired by \nElm Architecture v0.16 example\n.", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#counter-vanilla", 
            "text": "Source code  Demo  The most trivial example. Uses \"vanilla\" JavaScript to render a UI.", 
            "title": "Counter Vanilla"
        }, 
        {
            "location": "/examples/#counter", 
            "text": "Source code  Demo  The basic example of using Carry with  carry-reagent \nfor rendering UI using  Reagent .", 
            "title": "Counter"
        }, 
        {
            "location": "/examples/#friend-list", 
            "text": "Source code  Demo  Inspired by this  problem  about dynamic search input.\nDemonstrates how to dispatch new signals from signal handler and also features:   carry-reagent \nfor rendering UI using  Reagent  carry-history  for routing  carry-schema  for model validation using  Schema  carry-debugger  for time traveling debugging  carry-logging  for logging to console  unit tests", 
            "title": "Friend List"
        }, 
        {
            "location": "/examples/#todomvc", 
            "text": "Source code  Demo  The implementation of  TodoMVC  reference example.  Features:   carry-reagent \nfor rendering UI using  Reagent  carry-history  and  Silk  for routing  carry-persistence  and  hodgepodge  for local storage persistence  carry-schema  for model validation using  Schema  carry-debugger  for time traveling debugging  carry-logging  for logging to console  uses  Specter  for model updates  carry-atom-sync  to directly access app model as an atom in REPL", 
            "title": "TodoMVC"
        }, 
        {
            "location": "/examples/#pickings", 
            "text": "Source code  The small desktop app using Carry.  Features:   written in Clojure  Seesaw  for UI  reloaded workflow  for easier running from REPL", 
            "title": "Pickings"
        }, 
        {
            "location": "/examples/#apps-using-datascript", 
            "text": "", 
            "title": "Apps Using DataScript"
        }, 
        {
            "location": "/examples/#counter-datascript", 
            "text": "Source code  Demo  The simplest example of using  DataScript  in-memory database for a model and  carry-reagent \nfor rendering UI using  Reagent .", 
            "title": "Counter DataScript"
        }, 
        {
            "location": "/examples/#shopping-cart", 
            "text": "Source code  Demo  The more advanced example of using  DataScript  \nand  carry-reagent .\nInspired by  flux-comparison  problem.", 
            "title": "Shopping Cart"
        }, 
        {
            "location": "/examples/#counter-devcards", 
            "text": "Source code  Demo  An example of rendering  counter app  in  Devcards .\nAlso see  guide .  Features:   carry-atom-sync  for making Devcards history work seamlessly with Carry  carry-reagent \nfor rendering UI using  Reagent    carry-logging  for logging to console", 
            "title": "Counter Devcards"
        }, 
        {
            "location": "/examples/#blueprint-splitting", 
            "text": "See  guide .", 
            "title": "Blueprint Splitting"
        }, 
        {
            "location": "/examples/#hof", 
            "text": "Source code  Demo  Demonstrates how to assemble a blueprint and UI from multiple modules using higher-order functions.   Features:   carry-reagent \nfor rendering UI using  Reagent", 
            "title": "HOF"
        }, 
        {
            "location": "/examples/#multimethods", 
            "text": "Source code  Demo  Demonstrates how to assemble a blueprint from multiple modules with a help of multimethods.   Features:   carry-reagent \nfor rendering UI using  Reagent", 
            "title": "Multimethods"
        }, 
        {
            "location": "/examples/#multimethods-corematch", 
            "text": "Source code  Demo  Demonstrates how to assemble a blueprint from multiple modules with a help of multimethods and  core.match .   Features:   carry-reagent \nfor rendering UI using  Reagent", 
            "title": "Multimethods &amp; core.match"
        }, 
        {
            "location": "/examples/#composite-apps", 
            "text": "See  guide .", 
            "title": "Composite Apps"
        }, 
        {
            "location": "/examples/#subapps", 
            "text": "Source code  Demo  In this project  counter app  and  friend list app  instances are \"statically\" added to the app blueprint.\nSeveral helper methods are extracted to make it easy to include any subapp at the time of app instantiation.", 
            "title": "Subapps"
        }, 
        {
            "location": "/examples/#counter-list", 
            "text": "Source code  Demo  In this example  counter app  instances are created and removed dynamically after app is started.\nInspired by  Elm Architecture v0.16 example .", 
            "title": "Counter List"
        }, 
        {
            "location": "/api/", 
            "text": "It is a placeholder file, it will be replaced by API Reference docs generated by external tool.", 
            "title": "API Reference"
        }, 
        {
            "location": "/faq/", 
            "text": "What are the alternative ClojureScript frameworks?\n\n\nSome of the alternatives are:\n\n\n\n\nampere\n\n\nbureaucracy\n\n\nCatalysis\n\n\nhoplon\n\n\nKeechma\n\n\nOm Next\n\n\nPetrol\n\n\nPure-frame\n\n\nre-frame\n\n\nremlok\n\n\nStately\n\n\nuntangled\n\n\n\n\nFor comparison also take a look at the list of different TodoMVC examples at \n\nhttps://github.com/gadfly361/cljs-todomvc\n.\n\n\nIs view model an integral part of Carry architecture?\n\n\nNo, but it's a convenient UI pattern to follow because:\n\n\n\n\nIt makes code easier to read, refactor and unit test thanks to better separation of concerns. \n\n\nIt makes performance optimizations easier (e.g. by using Reagent's reactions to not recalculate data without a need).\n\n\n\n\nThat's why it was enforced in \ncarry-reagent\n package.\n\n\nIs there a way to code a view model if I don't use Reagent?\n\n\nYes, there's a number of tools that can do reactive/dataflow/structured computations:\n\n\n\n\nDerivatives\n\n\nfreactive.core\n\n\nJavelin\n\n\nlentes\n\n\nPlumatic Graph\n\n\nRum\n's \nderived-atom\n\n\n\n\nIs using \ncore.match\n required in signal/action handlers?\n\n\nNo, Carry doesn't care how these functions are implemented. They can be driven by multimethods or a simple \ncond\n.\nBut using \ncore.match\n seemed to me like quite a flexible and readable solution.", 
            "title": "FAQ"
        }, 
        {
            "location": "/faq/#what-are-the-alternative-clojurescript-frameworks", 
            "text": "Some of the alternatives are:   ampere  bureaucracy  Catalysis  hoplon  Keechma  Om Next  Petrol  Pure-frame  re-frame  remlok  Stately  untangled   For comparison also take a look at the list of different TodoMVC examples at  https://github.com/gadfly361/cljs-todomvc .", 
            "title": "What are the alternative ClojureScript frameworks?"
        }, 
        {
            "location": "/faq/#is-view-model-an-integral-part-of-carry-architecture", 
            "text": "No, but it's a convenient UI pattern to follow because:   It makes code easier to read, refactor and unit test thanks to better separation of concerns.   It makes performance optimizations easier (e.g. by using Reagent's reactions to not recalculate data without a need).   That's why it was enforced in  carry-reagent  package.", 
            "title": "Is view model an integral part of Carry architecture?"
        }, 
        {
            "location": "/faq/#is-there-a-way-to-code-a-view-model-if-i-dont-use-reagent", 
            "text": "Yes, there's a number of tools that can do reactive/dataflow/structured computations:   Derivatives  freactive.core  Javelin  lentes  Plumatic Graph  Rum 's  derived-atom", 
            "title": "Is there a way to code a view model if I don't use Reagent?"
        }, 
        {
            "location": "/faq/#is-using-corematch-required-in-signalaction-handlers", 
            "text": "No, Carry doesn't care how these functions are implemented. They can be driven by multimethods or a simple  cond .\nBut using  core.match  seemed to me like quite a flexible and readable solution.", 
            "title": "Is using core.match required in signal/action handlers?"
        }, 
        {
            "location": "/dev-guide/", 
            "text": "Tests\n\n\nAutorun Clojure tests: \nlein test-refresh\n\n\nAutorun ClojureScript tests: \nlein doo phantom test auto\n\n\nDocumentation\n\n\nProject uses \nMkDocs\n with \nCinder\n theme and \nPlantUML\n to generate documentation static site.\n\nCodox\n is used to generate API reference.\nTasks are scripted using \nPyInvoke\n.\n\n\nServe site pages locally with automatic build (but it won't work for index page): \nmkdocs serve\n\n\nBuild only site pages: \ninv mkdocs\n\n\nBuild API reference into site folder: \ninv api\n\n\nBuild graphs into site folder: \ninv graphs\n\n\nBuild examples into site folder: \ninv examples\n\n\nBuild the whole site: \ninv site\n\n\nDeploying\n\n\nDeploy to Clojars: \nlein deploy clojars\n\n\nDeploy site to gh-pages branch: \nghp-import -p site", 
            "title": "Developer Guide"
        }, 
        {
            "location": "/dev-guide/#tests", 
            "text": "Autorun Clojure tests:  lein test-refresh  Autorun ClojureScript tests:  lein doo phantom test auto", 
            "title": "Tests"
        }, 
        {
            "location": "/dev-guide/#documentation", 
            "text": "Project uses  MkDocs  with  Cinder  theme and  PlantUML  to generate documentation static site. Codox  is used to generate API reference.\nTasks are scripted using  PyInvoke .  Serve site pages locally with automatic build (but it won't work for index page):  mkdocs serve  Build only site pages:  inv mkdocs  Build API reference into site folder:  inv api  Build graphs into site folder:  inv graphs  Build examples into site folder:  inv examples  Build the whole site:  inv site", 
            "title": "Documentation"
        }, 
        {
            "location": "/dev-guide/#deploying", 
            "text": "Deploy to Clojars:  lein deploy clojars  Deploy site to gh-pages branch:  ghp-import -p site", 
            "title": "Deploying"
        }
    ]
}